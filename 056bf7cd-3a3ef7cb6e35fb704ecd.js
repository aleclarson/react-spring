;(window.webpackJsonp = window.webpackJsonp || []).push([
  [2],
  {
    cSo1: function (t, e, i) {
      'use strict'
      ;(function (t) {
        i.d(e, 'a', function () {
          return Ai
        })
        i('nWfQ'),
          i('E5k/'),
          i('zGcK'),
          i('wZFJ'),
          i('HXzo'),
          i('nMRu'),
          i('AqHK'),
          i('JHok'),
          i('U6Bt'),
          i('OeI1'),
          i('1/Ks'),
          i('QzX/'),
          i('LagC'),
          i('pS08'),
          i('R48M')
        var s = i('1OyB'),
          r = i('vuIU'),
          n = i('ReuC'),
          a = i('Ji7U'),
          o = i('md7G'),
          p = i('foSv')
        i('Ll4R'),
          i('m210'),
          i('4DPX'),
          i('sc67'),
          i('rzGZ'),
          i('Dq+y'),
          i('Ggvi'),
          i('pJf4'),
          i('+ar0'),
          i('Kz6e'),
          i('HQhv'),
          i('lFjb'),
          i('sC2a'),
          i('MIFh'),
          i('q8oJ'),
          i('C9fy'),
          i('8npG'),
          i('klQ5')
        function h(t) {
          return function () {
            var e,
              i = Object(p.a)(t)
            if (c()) {
              var s = Object(p.a)(this).constructor
              e = Reflect.construct(i, arguments, s)
            } else e = i.apply(this, arguments)
            return Object(o.a)(this, e)
          }
        }
        function c() {
          if ('undefined' == typeof Reflect || !Reflect.construct) return !1
          if (Reflect.construct.sham) return !1
          if ('function' == typeof Proxy) return !0
          try {
            return (
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              ),
              !0
            )
          } catch (u) {
            return !1
          }
        }
        var l = {
            3: 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile',
            5: 'class enum extends super const export import',
            6: 'enum',
            strict:
              'implements interface let package private protected public static yield',
            strictBind: 'eval arguments',
          },
          u =
            'break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this',
          d = { 5: u, 6: u + ' const class extends export import super' },
          f = /^in(stanceof)?$/,
          m =
            'ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿯ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞹꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ',
          y =
            '‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿',
          g = new RegExp('[' + m + ']'),
          v = new RegExp('[' + m + y + ']')
        m = y = null
        var x = [
            0,
            11,
            2,
            25,
            2,
            18,
            2,
            1,
            2,
            14,
            3,
            13,
            35,
            122,
            70,
            52,
            268,
            28,
            4,
            48,
            48,
            31,
            14,
            29,
            6,
            37,
            11,
            29,
            3,
            35,
            5,
            7,
            2,
            4,
            43,
            157,
            19,
            35,
            5,
            35,
            5,
            39,
            9,
            51,
            157,
            310,
            10,
            21,
            11,
            7,
            153,
            5,
            3,
            0,
            2,
            43,
            2,
            1,
            4,
            0,
            3,
            22,
            11,
            22,
            10,
            30,
            66,
            18,
            2,
            1,
            11,
            21,
            11,
            25,
            71,
            55,
            7,
            1,
            65,
            0,
            16,
            3,
            2,
            2,
            2,
            28,
            43,
            28,
            4,
            28,
            36,
            7,
            2,
            27,
            28,
            53,
            11,
            21,
            11,
            18,
            14,
            17,
            111,
            72,
            56,
            50,
            14,
            50,
            14,
            35,
            477,
            28,
            11,
            0,
            9,
            21,
            190,
            52,
            76,
            44,
            33,
            24,
            27,
            35,
            30,
            0,
            12,
            34,
            4,
            0,
            13,
            47,
            15,
            3,
            22,
            0,
            2,
            0,
            36,
            17,
            2,
            24,
            85,
            6,
            2,
            0,
            2,
            3,
            2,
            14,
            2,
            9,
            8,
            46,
            39,
            7,
            3,
            1,
            3,
            21,
            2,
            6,
            2,
            1,
            2,
            4,
            4,
            0,
            19,
            0,
            13,
            4,
            159,
            52,
            19,
            3,
            54,
            47,
            21,
            1,
            2,
            0,
            185,
            46,
            42,
            3,
            37,
            47,
            21,
            0,
            60,
            42,
            86,
            26,
            230,
            43,
            117,
            63,
            32,
            0,
            257,
            0,
            11,
            39,
            8,
            0,
            22,
            0,
            12,
            39,
            3,
            3,
            20,
            0,
            35,
            56,
            264,
            8,
            2,
            36,
            18,
            0,
            50,
            29,
            113,
            6,
            2,
            1,
            2,
            37,
            22,
            0,
            26,
            5,
            2,
            1,
            2,
            31,
            15,
            0,
            328,
            18,
            270,
            921,
            103,
            110,
            18,
            195,
            2749,
            1070,
            4050,
            582,
            8634,
            568,
            8,
            30,
            114,
            29,
            19,
            47,
            17,
            3,
            32,
            20,
            6,
            18,
            689,
            63,
            129,
            68,
            12,
            0,
            67,
            12,
            65,
            1,
            31,
            6129,
            15,
            754,
            9486,
            286,
            82,
            395,
            2309,
            106,
            6,
            12,
            4,
            8,
            8,
            9,
            5991,
            84,
            2,
            70,
            2,
            1,
            3,
            0,
            3,
            1,
            3,
            3,
            2,
            11,
            2,
            0,
            2,
            6,
            2,
            64,
            2,
            3,
            3,
            7,
            2,
            6,
            2,
            27,
            2,
            3,
            2,
            4,
            2,
            0,
            4,
            6,
            2,
            339,
            3,
            24,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            7,
            4149,
            196,
            60,
            67,
            1213,
            3,
            2,
            26,
            2,
            1,
            2,
            0,
            3,
            0,
            2,
            9,
            2,
            3,
            2,
            0,
            2,
            0,
            7,
            0,
            5,
            0,
            2,
            0,
            2,
            0,
            2,
            2,
            2,
            1,
            2,
            0,
            3,
            0,
            2,
            0,
            2,
            0,
            2,
            0,
            2,
            0,
            2,
            1,
            2,
            0,
            3,
            3,
            2,
            6,
            2,
            3,
            2,
            3,
            2,
            0,
            2,
            9,
            2,
            16,
            6,
            2,
            2,
            4,
            2,
            16,
            4421,
            42710,
            42,
            4148,
            12,
            221,
            3,
            5761,
            15,
            7472,
            3104,
            541,
          ],
          b = [
            509,
            0,
            227,
            0,
            150,
            4,
            294,
            9,
            1368,
            2,
            2,
            1,
            6,
            3,
            41,
            2,
            5,
            0,
            166,
            1,
            574,
            3,
            9,
            9,
            525,
            10,
            176,
            2,
            54,
            14,
            32,
            9,
            16,
            3,
            46,
            10,
            54,
            9,
            7,
            2,
            37,
            13,
            2,
            9,
            6,
            1,
            45,
            0,
            13,
            2,
            49,
            13,
            9,
            3,
            4,
            9,
            83,
            11,
            7,
            0,
            161,
            11,
            6,
            9,
            7,
            3,
            56,
            1,
            2,
            6,
            3,
            1,
            3,
            2,
            10,
            0,
            11,
            1,
            3,
            6,
            4,
            4,
            193,
            17,
            10,
            9,
            5,
            0,
            82,
            19,
            13,
            9,
            214,
            6,
            3,
            8,
            28,
            1,
            83,
            16,
            16,
            9,
            82,
            12,
            9,
            9,
            84,
            14,
            5,
            9,
            243,
            14,
            166,
            9,
            280,
            9,
            41,
            6,
            2,
            3,
            9,
            0,
            10,
            10,
            47,
            15,
            406,
            7,
            2,
            7,
            17,
            9,
            57,
            21,
            2,
            13,
            123,
            5,
            4,
            0,
            2,
            1,
            2,
            6,
            2,
            0,
            9,
            9,
            49,
            4,
            2,
            1,
            2,
            4,
            9,
            9,
            330,
            3,
            19306,
            9,
            135,
            4,
            60,
            6,
            26,
            9,
            1016,
            45,
            17,
            3,
            19723,
            1,
            5319,
            4,
            4,
            5,
            9,
            7,
            3,
            6,
            31,
            3,
            149,
            2,
            1418,
            49,
            513,
            54,
            5,
            49,
            9,
            0,
            15,
            0,
            23,
            4,
            2,
            14,
            1361,
            6,
            2,
            16,
            3,
            6,
            2,
            1,
            2,
            4,
            2214,
            6,
            110,
            6,
            6,
            9,
            792487,
            239,
          ]
        function _(t, e) {
          for (var i = 65536, s = 0; s < e.length; s += 2) {
            if ((i += e[s]) > t) return !1
            if ((i += e[s + 1]) >= t) return !0
          }
        }
        function k(t, e) {
          return t < 65
            ? 36 === t
            : t < 91 ||
                (t < 97
                  ? 95 === t
                  : t < 123 ||
                    (t <= 65535
                      ? t >= 170 && g.test(String.fromCharCode(t))
                      : !1 !== e && _(t, x)))
        }
        function S(t, e) {
          return t < 48
            ? 36 === t
            : t < 58 ||
                (!(t < 65) &&
                  (t < 91 ||
                    (t < 97
                      ? 95 === t
                      : t < 123 ||
                        (t <= 65535
                          ? t >= 170 && v.test(String.fromCharCode(t))
                          : !1 !== e && (_(t, x) || _(t, b))))))
        }
        var w = function (t, e) {
          void 0 === e && (e = {}),
            (this.label = t),
            (this.keyword = e.keyword),
            (this.beforeExpr = !!e.beforeExpr),
            (this.startsExpr = !!e.startsExpr),
            (this.isLoop = !!e.isLoop),
            (this.isAssign = !!e.isAssign),
            (this.prefix = !!e.prefix),
            (this.postfix = !!e.postfix),
            (this.binop = e.binop || null),
            (this.updateContext = null)
        }
        function E(t, e) {
          return new w(t, { beforeExpr: !0, binop: e })
        }
        var C = { beforeExpr: !0 },
          A = { startsExpr: !0 },
          I = {}
        function L(t, e) {
          return void 0 === e && (e = {}), (e.keyword = t), (I[t] = new w(t, e))
        }
        var P = {
            num: new w('num', A),
            regexp: new w('regexp', A),
            string: new w('string', A),
            name: new w('name', A),
            eof: new w('eof'),
            bracketL: new w('[', { beforeExpr: !0, startsExpr: !0 }),
            bracketR: new w(']'),
            braceL: new w('{', { beforeExpr: !0, startsExpr: !0 }),
            braceR: new w('}'),
            parenL: new w('(', { beforeExpr: !0, startsExpr: !0 }),
            parenR: new w(')'),
            comma: new w(',', C),
            semi: new w(';', C),
            colon: new w(':', C),
            dot: new w('.'),
            question: new w('?', C),
            arrow: new w('=>', C),
            template: new w('template'),
            invalidTemplate: new w('invalidTemplate'),
            ellipsis: new w('...', C),
            backQuote: new w('`', A),
            dollarBraceL: new w('${', { beforeExpr: !0, startsExpr: !0 }),
            eq: new w('=', { beforeExpr: !0, isAssign: !0 }),
            assign: new w('_=', { beforeExpr: !0, isAssign: !0 }),
            incDec: new w('++/--', { prefix: !0, postfix: !0, startsExpr: !0 }),
            prefix: new w('!/~', {
              beforeExpr: !0,
              prefix: !0,
              startsExpr: !0,
            }),
            logicalOR: E('||', 1),
            logicalAND: E('&&', 2),
            bitwiseOR: E('|', 3),
            bitwiseXOR: E('^', 4),
            bitwiseAND: E('&', 5),
            equality: E('==/!=/===/!==', 6),
            relational: E('</>/<=/>=', 7),
            bitShift: E('<</>>/>>>', 8),
            plusMin: new w('+/-', {
              beforeExpr: !0,
              binop: 9,
              prefix: !0,
              startsExpr: !0,
            }),
            modulo: E('%', 10),
            star: E('*', 10),
            slash: E('/', 10),
            starstar: new w('**', { beforeExpr: !0 }),
            _break: L('break'),
            _case: L('case', C),
            _catch: L('catch'),
            _continue: L('continue'),
            _debugger: L('debugger'),
            _default: L('default', C),
            _do: L('do', { isLoop: !0, beforeExpr: !0 }),
            _else: L('else', C),
            _finally: L('finally'),
            _for: L('for', { isLoop: !0 }),
            _function: L('function', A),
            _if: L('if'),
            _return: L('return', C),
            _switch: L('switch'),
            _throw: L('throw', C),
            _try: L('try'),
            _var: L('var'),
            _const: L('const'),
            _while: L('while', { isLoop: !0 }),
            _with: L('with'),
            _new: L('new', { beforeExpr: !0, startsExpr: !0 }),
            _this: L('this', A),
            _super: L('super', A),
            _class: L('class', A),
            _extends: L('extends', C),
            _export: L('export'),
            _import: L('import'),
            _null: L('null', A),
            _true: L('true', A),
            _false: L('false', A),
            _in: L('in', { beforeExpr: !0, binop: 7 }),
            _instanceof: L('instanceof', { beforeExpr: !0, binop: 7 }),
            _typeof: L('typeof', {
              beforeExpr: !0,
              prefix: !0,
              startsExpr: !0,
            }),
            _void: L('void', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
            _delete: L('delete', {
              beforeExpr: !0,
              prefix: !0,
              startsExpr: !0,
            }),
          },
          N = /\r\n?|\n|\u2028|\u2029/,
          O = new RegExp(N.source, 'g')
        function j(t, e) {
          return 10 === t || 13 === t || (!e && (8232 === t || 8233 === t))
        }
        var T = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,
          R = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
          V = Object.prototype,
          D = V.hasOwnProperty,
          B = V.toString
        function F(t, e) {
          return D.call(t, e)
        }
        var M =
          Array.isArray ||
          function (t) {
            return '[object Array]' === B.call(t)
          }
        function U(t) {
          return new RegExp('^(?:' + t.replace(/ /g, '|') + ')$')
        }
        var q = function (t, e) {
          ;(this.line = t), (this.column = e)
        }
        q.prototype.offset = function (t) {
          return new q(this.line, this.column + t)
        }
        var J = function (t, e, i) {
          ;(this.start = e),
            (this.end = i),
            null !== t.sourceFile && (this.source = t.sourceFile)
        }
        function X(t, e) {
          for (var i = 1, s = 0; ; ) {
            O.lastIndex = s
            var r = O.exec(t)
            if (!(r && r.index < e)) return new q(i, e - s)
            ++i, (s = r.index + r[0].length)
          }
        }
        var z = {
          ecmaVersion: 9,
          sourceType: 'script',
          onInsertedSemicolon: null,
          onTrailingComma: null,
          allowReserved: null,
          allowReturnOutsideFunction: !1,
          allowImportExportEverywhere: !1,
          allowAwaitOutsideFunction: !1,
          allowHashBang: !1,
          locations: !1,
          onToken: null,
          onComment: null,
          ranges: !1,
          program: null,
          sourceFile: null,
          directSourceFile: null,
          preserveParens: !1,
        }
        function W(t, e) {
          return 2 | (t ? 4 : 0) | (e ? 8 : 0)
        }
        var H = function (t, e, i) {
            ;(this.options = t = (function (t) {
              var e = {}
              for (var i in z) e[i] = t && F(t, i) ? t[i] : z[i]
              if (
                (e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009),
                null == e.allowReserved &&
                  (e.allowReserved = e.ecmaVersion < 5),
                M(e.onToken))
              ) {
                var s = e.onToken
                e.onToken = function (t) {
                  return s.push(t)
                }
              }
              return (
                M(e.onComment) &&
                  (e.onComment = (function (t, e) {
                    return function (i, s, r, n, a, o) {
                      var p = {
                        type: i ? 'Block' : 'Line',
                        value: s,
                        start: r,
                        end: n,
                      }
                      t.locations && (p.loc = new J(this, a, o)),
                        t.ranges && (p.range = [r, n]),
                        e.push(p)
                    }
                  })(e, e.onComment)),
                e
              )
            })(t)),
              (this.sourceFile = t.sourceFile),
              (this.keywords = U(d[t.ecmaVersion >= 6 ? 6 : 5]))
            var s = ''
            if (!t.allowReserved) {
              for (var r = t.ecmaVersion; !(s = l[r]); r--);
              'module' === t.sourceType && (s += ' await')
            }
            this.reservedWords = U(s)
            var n = (s ? s + ' ' : '') + l.strict
            ;(this.reservedWordsStrict = U(n)),
              (this.reservedWordsStrictBind = U(n + ' ' + l.strictBind)),
              (this.input = String(e)),
              (this.containsEsc = !1),
              i
                ? ((this.pos = i),
                  (this.lineStart = this.input.lastIndexOf('\n', i - 1) + 1),
                  (this.curLine = this.input
                    .slice(0, this.lineStart)
                    .split(N).length))
                : ((this.pos = this.lineStart = 0), (this.curLine = 1)),
              (this.type = P.eof),
              (this.value = null),
              (this.start = this.end = this.pos),
              (this.startLoc = this.endLoc = this.curPosition()),
              (this.lastTokEndLoc = this.lastTokStartLoc = null),
              (this.lastTokStart = this.lastTokEnd = this.pos),
              (this.context = this.initialContext()),
              (this.exprAllowed = !0),
              (this.inModule = 'module' === t.sourceType),
              (this.strict = this.inModule || this.strictDirective(this.pos)),
              (this.potentialArrowAt = -1),
              (this.yieldPos = this.awaitPos = this.awaitIdentPos = 0),
              (this.labels = []),
              (this.undefinedExports = {}),
              0 === this.pos &&
                t.allowHashBang &&
                '#!' === this.input.slice(0, 2) &&
                this.skipLineComment(2),
              (this.scopeStack = []),
              this.enterScope(1),
              (this.regexpState = null)
          },
          G = {
            inFunction: { configurable: !0 },
            inGenerator: { configurable: !0 },
            inAsync: { configurable: !0 },
            allowSuper: { configurable: !0 },
            allowDirectSuper: { configurable: !0 },
            treatFunctionsAsVar: { configurable: !0 },
          }
        ;(H.prototype.parse = function () {
          var t = this.options.program || this.startNode()
          return this.nextToken(), this.parseTopLevel(t)
        }),
          (G.inFunction.get = function () {
            return (2 & this.currentVarScope().flags) > 0
          }),
          (G.inGenerator.get = function () {
            return (8 & this.currentVarScope().flags) > 0
          }),
          (G.inAsync.get = function () {
            return (4 & this.currentVarScope().flags) > 0
          }),
          (G.allowSuper.get = function () {
            return (64 & this.currentThisScope().flags) > 0
          }),
          (G.allowDirectSuper.get = function () {
            return (128 & this.currentThisScope().flags) > 0
          }),
          (G.treatFunctionsAsVar.get = function () {
            return this.treatFunctionsAsVarInScope(this.currentScope())
          }),
          (H.prototype.inNonArrowFunction = function () {
            return (2 & this.currentThisScope().flags) > 0
          }),
          (H.extend = function () {
            for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e]
            for (var i = this, s = 0; s < t.length; s++) i = t[s](i)
            return i
          }),
          (H.parse = function (t, e) {
            return new this(e, t).parse()
          }),
          (H.parseExpressionAt = function (t, e, i) {
            var s = new this(i, t, e)
            return s.nextToken(), s.parseExpression()
          }),
          (H.tokenizer = function (t, e) {
            return new this(e, t)
          }),
          Object.defineProperties(H.prototype, G)
        var Q = H.prototype,
          K = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/
        function $() {
          this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1
        }
        ;(Q.strictDirective = function (t) {
          for (;;) {
            ;(R.lastIndex = t), (t += R.exec(this.input)[0].length)
            var e = K.exec(this.input.slice(t))
            if (!e) return !1
            if ('use strict' === (e[1] || e[2])) return !0
            ;(R.lastIndex = t += e[0].length),
              (t += R.exec(this.input)[0].length),
              ';' === this.input[t] && t++
          }
        }),
          (Q.eat = function (t) {
            return this.type === t && (this.next(), !0)
          }),
          (Q.isContextual = function (t) {
            return this.type === P.name && this.value === t && !this.containsEsc
          }),
          (Q.eatContextual = function (t) {
            return !!this.isContextual(t) && (this.next(), !0)
          }),
          (Q.expectContextual = function (t) {
            this.eatContextual(t) || this.unexpected()
          }),
          (Q.canInsertSemicolon = function () {
            return (
              this.type === P.eof ||
              this.type === P.braceR ||
              N.test(this.input.slice(this.lastTokEnd, this.start))
            )
          }),
          (Q.insertSemicolon = function () {
            if (this.canInsertSemicolon())
              return (
                this.options.onInsertedSemicolon &&
                  this.options.onInsertedSemicolon(
                    this.lastTokEnd,
                    this.lastTokEndLoc
                  ),
                !0
              )
          }),
          (Q.semicolon = function () {
            this.eat(P.semi) || this.insertSemicolon() || this.unexpected()
          }),
          (Q.afterTrailingComma = function (t, e) {
            if (this.type === t)
              return (
                this.options.onTrailingComma &&
                  this.options.onTrailingComma(
                    this.lastTokStart,
                    this.lastTokStartLoc
                  ),
                e || this.next(),
                !0
              )
          }),
          (Q.expect = function (t) {
            this.eat(t) || this.unexpected()
          }),
          (Q.unexpected = function (t) {
            this.raise(null != t ? t : this.start, 'Unexpected token')
          }),
          (Q.checkPatternErrors = function (t, e) {
            if (t) {
              t.trailingComma > -1 &&
                this.raiseRecoverable(
                  t.trailingComma,
                  'Comma is not permitted after the rest element'
                )
              var i = e ? t.parenthesizedAssign : t.parenthesizedBind
              i > -1 && this.raiseRecoverable(i, 'Parenthesized pattern')
            }
          }),
          (Q.checkExpressionErrors = function (t, e) {
            if (!t) return !1
            var i = t.shorthandAssign,
              s = t.doubleProto
            if (!e) return i >= 0 || s >= 0
            i >= 0 &&
              this.raise(
                i,
                'Shorthand property assignments are valid only in destructuring patterns'
              ),
              s >= 0 &&
                this.raiseRecoverable(s, 'Redefinition of __proto__ property')
          }),
          (Q.checkYieldAwaitInDefaultParams = function () {
            this.yieldPos &&
              (!this.awaitPos || this.yieldPos < this.awaitPos) &&
              this.raise(
                this.yieldPos,
                'Yield expression cannot be a default value'
              ),
              this.awaitPos &&
                this.raise(
                  this.awaitPos,
                  'Await expression cannot be a default value'
                )
          }),
          (Q.isSimpleAssignTarget = function (t) {
            return 'ParenthesizedExpression' === t.type
              ? this.isSimpleAssignTarget(t.expression)
              : 'Identifier' === t.type || 'MemberExpression' === t.type
          })
        var Z = H.prototype
        Z.parseTopLevel = function (t) {
          var e = {}
          for (t.body || (t.body = []); this.type !== P.eof; ) {
            var i = this.parseStatement(null, !0, e)
            t.body.push(i)
          }
          if (this.inModule)
            for (
              var s = 0, r = Object.keys(this.undefinedExports);
              s < r.length;
              s += 1
            ) {
              var n = r[s]
              this.raiseRecoverable(
                this.undefinedExports[n].start,
                "Export '" + n + "' is not defined"
              )
            }
          return (
            this.adaptDirectivePrologue(t.body),
            this.next(),
            this.options.ecmaVersion >= 6 &&
              (t.sourceType = this.options.sourceType),
            this.finishNode(t, 'Program')
          )
        }
        var Y = { kind: 'loop' },
          tt = { kind: 'switch' }
        ;(Z.isLet = function (t) {
          if (this.options.ecmaVersion < 6 || !this.isContextual('let'))
            return !1
          R.lastIndex = this.pos
          var e = R.exec(this.input),
            i = this.pos + e[0].length,
            s = this.input.charCodeAt(i)
          if (91 === s) return !0
          if (t) return !1
          if (123 === s) return !0
          if (k(s, !0)) {
            for (var r = i + 1; S(this.input.charCodeAt(r), !0); ) ++r
            var n = this.input.slice(i, r)
            if (!f.test(n)) return !0
          }
          return !1
        }),
          (Z.isAsyncFunction = function () {
            if (this.options.ecmaVersion < 8 || !this.isContextual('async'))
              return !1
            R.lastIndex = this.pos
            var t = R.exec(this.input),
              e = this.pos + t[0].length
            return !(
              N.test(this.input.slice(this.pos, e)) ||
              'function' !== this.input.slice(e, e + 8) ||
              (e + 8 !== this.input.length && S(this.input.charAt(e + 8)))
            )
          }),
          (Z.parseStatement = function (t, e, i) {
            var s,
              r = this.type,
              n = this.startNode()
            switch ((this.isLet(t) && ((r = P._var), (s = 'let')), r)) {
              case P._break:
              case P._continue:
                return this.parseBreakContinueStatement(n, r.keyword)
              case P._debugger:
                return this.parseDebuggerStatement(n)
              case P._do:
                return this.parseDoStatement(n)
              case P._for:
                return this.parseForStatement(n)
              case P._function:
                return (
                  t &&
                    (this.strict || ('if' !== t && 'label' !== t)) &&
                    this.options.ecmaVersion >= 6 &&
                    this.unexpected(),
                  this.parseFunctionStatement(n, !1, !t)
                )
              case P._class:
                return t && this.unexpected(), this.parseClass(n, !0)
              case P._if:
                return this.parseIfStatement(n)
              case P._return:
                return this.parseReturnStatement(n)
              case P._switch:
                return this.parseSwitchStatement(n)
              case P._throw:
                return this.parseThrowStatement(n)
              case P._try:
                return this.parseTryStatement(n)
              case P._const:
              case P._var:
                return (
                  (s = s || this.value),
                  t && 'var' !== s && this.unexpected(),
                  this.parseVarStatement(n, s)
                )
              case P._while:
                return this.parseWhileStatement(n)
              case P._with:
                return this.parseWithStatement(n)
              case P.braceL:
                return this.parseBlock(!0, n)
              case P.semi:
                return this.parseEmptyStatement(n)
              case P._export:
              case P._import:
                return (
                  this.options.allowImportExportEverywhere ||
                    (e ||
                      this.raise(
                        this.start,
                        "'import' and 'export' may only appear at the top level"
                      ),
                    this.inModule ||
                      this.raise(
                        this.start,
                        "'import' and 'export' may appear only with 'sourceType: module'"
                      )),
                  r === P._import ? this.parseImport(n) : this.parseExport(n, i)
                )
              default:
                if (this.isAsyncFunction())
                  return (
                    t && this.unexpected(),
                    this.next(),
                    this.parseFunctionStatement(n, !0, !t)
                  )
                var a = this.value,
                  o = this.parseExpression()
                return r === P.name &&
                  'Identifier' === o.type &&
                  this.eat(P.colon)
                  ? this.parseLabeledStatement(n, a, o, t)
                  : this.parseExpressionStatement(n, o)
            }
          }),
          (Z.parseBreakContinueStatement = function (t, e) {
            var i = 'break' === e
            this.next(),
              this.eat(P.semi) || this.insertSemicolon()
                ? (t.label = null)
                : this.type !== P.name
                ? this.unexpected()
                : ((t.label = this.parseIdent()), this.semicolon())
            for (var s = 0; s < this.labels.length; ++s) {
              var r = this.labels[s]
              if (null == t.label || r.name === t.label.name) {
                if (null != r.kind && (i || 'loop' === r.kind)) break
                if (t.label && i) break
              }
            }
            return (
              s === this.labels.length &&
                this.raise(t.start, 'Unsyntactic ' + e),
              this.finishNode(t, i ? 'BreakStatement' : 'ContinueStatement')
            )
          }),
          (Z.parseDebuggerStatement = function (t) {
            return (
              this.next(),
              this.semicolon(),
              this.finishNode(t, 'DebuggerStatement')
            )
          }),
          (Z.parseDoStatement = function (t) {
            return (
              this.next(),
              this.labels.push(Y),
              (t.body = this.parseStatement('do')),
              this.labels.pop(),
              this.expect(P._while),
              (t.test = this.parseParenExpression()),
              this.options.ecmaVersion >= 6
                ? this.eat(P.semi)
                : this.semicolon(),
              this.finishNode(t, 'DoWhileStatement')
            )
          }),
          (Z.parseForStatement = function (t) {
            this.next()
            var e =
              this.options.ecmaVersion >= 9 &&
              (this.inAsync ||
                (!this.inFunction && this.options.allowAwaitOutsideFunction)) &&
              this.eatContextual('await')
                ? this.lastTokStart
                : -1
            if (
              (this.labels.push(Y),
              this.enterScope(0),
              this.expect(P.parenL),
              this.type === P.semi)
            )
              return e > -1 && this.unexpected(e), this.parseFor(t, null)
            var i = this.isLet()
            if (this.type === P._var || this.type === P._const || i) {
              var s = this.startNode(),
                r = i ? 'let' : this.value
              return (
                this.next(),
                this.parseVar(s, !0, r),
                this.finishNode(s, 'VariableDeclaration'),
                !(
                  this.type === P._in ||
                  (this.options.ecmaVersion >= 6 && this.isContextual('of'))
                ) ||
                1 !== s.declarations.length ||
                ('var' !== r && s.declarations[0].init)
                  ? (e > -1 && this.unexpected(e), this.parseFor(t, s))
                  : (this.options.ecmaVersion >= 9 &&
                      (this.type === P._in
                        ? e > -1 && this.unexpected(e)
                        : (t.await = e > -1)),
                    this.parseForIn(t, s))
              )
            }
            var n = new $(),
              a = this.parseExpression(!0, n)
            return this.type === P._in ||
              (this.options.ecmaVersion >= 6 && this.isContextual('of'))
              ? (this.options.ecmaVersion >= 9 &&
                  (this.type === P._in
                    ? e > -1 && this.unexpected(e)
                    : (t.await = e > -1)),
                this.toAssignable(a, !1, n),
                this.checkLVal(a),
                this.parseForIn(t, a))
              : (this.checkExpressionErrors(n, !0),
                e > -1 && this.unexpected(e),
                this.parseFor(t, a))
          }),
          (Z.parseFunctionStatement = function (t, e, i) {
            return this.next(), this.parseFunction(t, it | (i ? 0 : st), !1, e)
          }),
          (Z.parseIfStatement = function (t) {
            return (
              this.next(),
              (t.test = this.parseParenExpression()),
              (t.consequent = this.parseStatement('if')),
              (t.alternate = this.eat(P._else)
                ? this.parseStatement('if')
                : null),
              this.finishNode(t, 'IfStatement')
            )
          }),
          (Z.parseReturnStatement = function (t) {
            return (
              this.inFunction ||
                this.options.allowReturnOutsideFunction ||
                this.raise(this.start, "'return' outside of function"),
              this.next(),
              this.eat(P.semi) || this.insertSemicolon()
                ? (t.argument = null)
                : ((t.argument = this.parseExpression()), this.semicolon()),
              this.finishNode(t, 'ReturnStatement')
            )
          }),
          (Z.parseSwitchStatement = function (t) {
            var e
            this.next(),
              (t.discriminant = this.parseParenExpression()),
              (t.cases = []),
              this.expect(P.braceL),
              this.labels.push(tt),
              this.enterScope(0)
            for (var i = !1; this.type !== P.braceR; )
              if (this.type === P._case || this.type === P._default) {
                var s = this.type === P._case
                e && this.finishNode(e, 'SwitchCase'),
                  t.cases.push((e = this.startNode())),
                  (e.consequent = []),
                  this.next(),
                  s
                    ? (e.test = this.parseExpression())
                    : (i &&
                        this.raiseRecoverable(
                          this.lastTokStart,
                          'Multiple default clauses'
                        ),
                      (i = !0),
                      (e.test = null)),
                  this.expect(P.colon)
              } else
                e || this.unexpected(),
                  e.consequent.push(this.parseStatement(null))
            return (
              this.exitScope(),
              e && this.finishNode(e, 'SwitchCase'),
              this.next(),
              this.labels.pop(),
              this.finishNode(t, 'SwitchStatement')
            )
          }),
          (Z.parseThrowStatement = function (t) {
            return (
              this.next(),
              N.test(this.input.slice(this.lastTokEnd, this.start)) &&
                this.raise(this.lastTokEnd, 'Illegal newline after throw'),
              (t.argument = this.parseExpression()),
              this.semicolon(),
              this.finishNode(t, 'ThrowStatement')
            )
          })
        var et = []
        ;(Z.parseTryStatement = function (t) {
          if (
            (this.next(),
            (t.block = this.parseBlock()),
            (t.handler = null),
            this.type === P._catch)
          ) {
            var e = this.startNode()
            if ((this.next(), this.eat(P.parenL))) {
              e.param = this.parseBindingAtom()
              var i = 'Identifier' === e.param.type
              this.enterScope(i ? 32 : 0),
                this.checkLVal(e.param, i ? 4 : 2),
                this.expect(P.parenR)
            } else
              this.options.ecmaVersion < 10 && this.unexpected(),
                (e.param = null),
                this.enterScope(0)
            ;(e.body = this.parseBlock(!1)),
              this.exitScope(),
              (t.handler = this.finishNode(e, 'CatchClause'))
          }
          return (
            (t.finalizer = this.eat(P._finally) ? this.parseBlock() : null),
            t.handler ||
              t.finalizer ||
              this.raise(t.start, 'Missing catch or finally clause'),
            this.finishNode(t, 'TryStatement')
          )
        }),
          (Z.parseVarStatement = function (t, e) {
            return (
              this.next(),
              this.parseVar(t, !1, e),
              this.semicolon(),
              this.finishNode(t, 'VariableDeclaration')
            )
          }),
          (Z.parseWhileStatement = function (t) {
            return (
              this.next(),
              (t.test = this.parseParenExpression()),
              this.labels.push(Y),
              (t.body = this.parseStatement('while')),
              this.labels.pop(),
              this.finishNode(t, 'WhileStatement')
            )
          }),
          (Z.parseWithStatement = function (t) {
            return (
              this.strict && this.raise(this.start, "'with' in strict mode"),
              this.next(),
              (t.object = this.parseParenExpression()),
              (t.body = this.parseStatement('with')),
              this.finishNode(t, 'WithStatement')
            )
          }),
          (Z.parseEmptyStatement = function (t) {
            return this.next(), this.finishNode(t, 'EmptyStatement')
          }),
          (Z.parseLabeledStatement = function (t, e, i, s) {
            for (var r = 0, n = this.labels; r < n.length; r += 1)
              n[r].name === e &&
                this.raise(i.start, "Label '" + e + "' is already declared")
            for (
              var a = this.type.isLoop
                  ? 'loop'
                  : this.type === P._switch
                  ? 'switch'
                  : null,
                o = this.labels.length - 1;
              o >= 0;
              o--
            ) {
              var p = this.labels[o]
              if (p.statementStart !== t.start) break
              ;(p.statementStart = this.start), (p.kind = a)
            }
            return (
              this.labels.push({
                name: e,
                kind: a,
                statementStart: this.start,
              }),
              (t.body = this.parseStatement(
                s ? (-1 === s.indexOf('label') ? s + 'label' : s) : 'label'
              )),
              this.labels.pop(),
              (t.label = i),
              this.finishNode(t, 'LabeledStatement')
            )
          }),
          (Z.parseExpressionStatement = function (t, e) {
            return (
              (t.expression = e),
              this.semicolon(),
              this.finishNode(t, 'ExpressionStatement')
            )
          }),
          (Z.parseBlock = function (t, e) {
            for (
              void 0 === t && (t = !0),
                void 0 === e && (e = this.startNode()),
                e.body = [],
                this.expect(P.braceL),
                t && this.enterScope(0);
              !this.eat(P.braceR);

            ) {
              var i = this.parseStatement(null)
              e.body.push(i)
            }
            return t && this.exitScope(), this.finishNode(e, 'BlockStatement')
          }),
          (Z.parseFor = function (t, e) {
            return (
              (t.init = e),
              this.expect(P.semi),
              (t.test = this.type === P.semi ? null : this.parseExpression()),
              this.expect(P.semi),
              (t.update =
                this.type === P.parenR ? null : this.parseExpression()),
              this.expect(P.parenR),
              (t.body = this.parseStatement('for')),
              this.exitScope(),
              this.labels.pop(),
              this.finishNode(t, 'ForStatement')
            )
          }),
          (Z.parseForIn = function (t, e) {
            var i = this.type === P._in ? 'ForInStatement' : 'ForOfStatement'
            return (
              this.next(),
              'ForInStatement' === i &&
                ('AssignmentPattern' === e.type ||
                  ('VariableDeclaration' === e.type &&
                    null != e.declarations[0].init &&
                    (this.strict ||
                      'Identifier' !== e.declarations[0].id.type))) &&
                this.raise(e.start, 'Invalid assignment in for-in loop head'),
              (t.left = e),
              (t.right =
                'ForInStatement' === i
                  ? this.parseExpression()
                  : this.parseMaybeAssign()),
              this.expect(P.parenR),
              (t.body = this.parseStatement('for')),
              this.exitScope(),
              this.labels.pop(),
              this.finishNode(t, i)
            )
          }),
          (Z.parseVar = function (t, e, i) {
            for (t.declarations = [], t.kind = i; ; ) {
              var s = this.startNode()
              if (
                (this.parseVarId(s, i),
                this.eat(P.eq)
                  ? (s.init = this.parseMaybeAssign(e))
                  : 'const' !== i ||
                    this.type === P._in ||
                    (this.options.ecmaVersion >= 6 && this.isContextual('of'))
                  ? 'Identifier' === s.id.type ||
                    (e && (this.type === P._in || this.isContextual('of')))
                    ? (s.init = null)
                    : this.raise(
                        this.lastTokEnd,
                        'Complex binding patterns require an initialization value'
                      )
                  : this.unexpected(),
                t.declarations.push(this.finishNode(s, 'VariableDeclarator')),
                !this.eat(P.comma))
              )
                break
            }
            return t
          }),
          (Z.parseVarId = function (t, e) {
            ;('const' !== e && 'let' !== e) ||
              !this.isContextual('let') ||
              this.raiseRecoverable(
                this.start,
                'let is disallowed as a lexically bound name'
              ),
              (t.id = this.parseBindingAtom()),
              this.checkLVal(t.id, 'var' === e ? 1 : 2, !1)
          })
        var it = 1,
          st = 2
        ;(Z.parseFunction = function (t, e, i, s) {
          this.initFunction(t),
            (this.options.ecmaVersion >= 9 ||
              (this.options.ecmaVersion >= 6 && !s)) &&
              (this.type === P.star && e & st && this.unexpected(),
              (t.generator = this.eat(P.star))),
            this.options.ecmaVersion >= 8 && (t.async = !!s),
            e & it &&
              ((t.id =
                4 & e && this.type !== P.name ? null : this.parseIdent()),
              !t.id ||
                e & st ||
                this.checkLVal(
                  t.id,
                  this.strict || t.generator || t.async
                    ? this.treatFunctionsAsVar
                      ? 1
                      : 2
                    : 3
                ))
          var r = this.yieldPos,
            n = this.awaitPos,
            a = this.awaitIdentPos
          return (
            (this.yieldPos = 0),
            (this.awaitPos = 0),
            (this.awaitIdentPos = 0),
            this.enterScope(W(t.async, t.generator)),
            e & it || (t.id = this.type === P.name ? this.parseIdent() : null),
            this.parseFunctionParams(t),
            this.parseFunctionBody(t, i, !1),
            (this.yieldPos = r),
            (this.awaitPos = n),
            (this.awaitIdentPos = a),
            this.finishNode(
              t,
              e & it ? 'FunctionDeclaration' : 'FunctionExpression'
            )
          )
        }),
          (Z.parseFunctionParams = function (t) {
            this.expect(P.parenL),
              (t.params = this.parseBindingList(
                P.parenR,
                !1,
                this.options.ecmaVersion >= 8
              )),
              this.checkYieldAwaitInDefaultParams()
          }),
          (Z.parseClass = function (t, e) {
            this.next()
            var i = this.strict
            ;(this.strict = !0),
              this.parseClassId(t, e),
              this.parseClassSuper(t)
            var s = this.startNode(),
              r = !1
            for (s.body = [], this.expect(P.braceL); !this.eat(P.braceR); ) {
              var n = this.parseClassElement(null !== t.superClass)
              n &&
                (s.body.push(n),
                'MethodDefinition' === n.type &&
                  'constructor' === n.kind &&
                  (r &&
                    this.raise(
                      n.start,
                      'Duplicate constructor in the same class'
                    ),
                  (r = !0)))
            }
            return (
              (t.body = this.finishNode(s, 'ClassBody')),
              (this.strict = i),
              this.finishNode(t, e ? 'ClassDeclaration' : 'ClassExpression')
            )
          }),
          (Z.parseClassElement = function (t) {
            var e = this
            if (this.eat(P.semi)) return null
            var i = this.startNode(),
              s = function (t, s) {
                void 0 === s && (s = !1)
                var r = e.start,
                  n = e.startLoc
                return !(
                  !e.eatContextual(t) ||
                  ((e.type === P.parenL || (s && e.canInsertSemicolon())) &&
                    (i.key && e.unexpected(),
                    (i.computed = !1),
                    (i.key = e.startNodeAt(r, n)),
                    (i.key.name = t),
                    e.finishNode(i.key, 'Identifier'),
                    1))
                )
              }
            ;(i.kind = 'method'), (i.static = s('static'))
            var r = this.eat(P.star),
              n = !1
            r ||
              (this.options.ecmaVersion >= 8 && s('async', !0)
                ? ((n = !0),
                  (r = this.options.ecmaVersion >= 9 && this.eat(P.star)))
                : s('get')
                ? (i.kind = 'get')
                : s('set') && (i.kind = 'set')),
              i.key || this.parsePropertyName(i)
            var a = i.key,
              o = !1
            return (
              i.computed ||
              i.static ||
              !(
                ('Identifier' === a.type && 'constructor' === a.name) ||
                ('Literal' === a.type && 'constructor' === a.value)
              )
                ? i.static &&
                  'Identifier' === a.type &&
                  'prototype' === a.name &&
                  this.raise(
                    a.start,
                    'Classes may not have a static property named prototype'
                  )
                : ('method' !== i.kind &&
                    this.raise(
                      a.start,
                      "Constructor can't have get/set modifier"
                    ),
                  r && this.raise(a.start, "Constructor can't be a generator"),
                  n &&
                    this.raise(a.start, "Constructor can't be an async method"),
                  (i.kind = 'constructor'),
                  (o = t)),
              this.parseClassMethod(i, r, n, o),
              'get' === i.kind &&
                0 !== i.value.params.length &&
                this.raiseRecoverable(
                  i.value.start,
                  'getter should have no params'
                ),
              'set' === i.kind &&
                1 !== i.value.params.length &&
                this.raiseRecoverable(
                  i.value.start,
                  'setter should have exactly one param'
                ),
              'set' === i.kind &&
                'RestElement' === i.value.params[0].type &&
                this.raiseRecoverable(
                  i.value.params[0].start,
                  'Setter cannot use rest params'
                ),
              i
            )
          }),
          (Z.parseClassMethod = function (t, e, i, s) {
            return (
              (t.value = this.parseMethod(e, i, s)),
              this.finishNode(t, 'MethodDefinition')
            )
          }),
          (Z.parseClassId = function (t, e) {
            this.type === P.name
              ? ((t.id = this.parseIdent()), e && this.checkLVal(t.id, 2, !1))
              : (!0 === e && this.unexpected(), (t.id = null))
          }),
          (Z.parseClassSuper = function (t) {
            t.superClass = this.eat(P._extends)
              ? this.parseExprSubscripts()
              : null
          }),
          (Z.parseExport = function (t, e) {
            if ((this.next(), this.eat(P.star)))
              return (
                this.expectContextual('from'),
                this.type !== P.string && this.unexpected(),
                (t.source = this.parseExprAtom()),
                this.semicolon(),
                this.finishNode(t, 'ExportAllDeclaration')
              )
            if (this.eat(P._default)) {
              var i
              if (
                (this.checkExport(e, 'default', this.lastTokStart),
                this.type === P._function || (i = this.isAsyncFunction()))
              ) {
                var s = this.startNode()
                this.next(),
                  i && this.next(),
                  (t.declaration = this.parseFunction(s, 4 | it, !1, i))
              } else if (this.type === P._class) {
                var r = this.startNode()
                t.declaration = this.parseClass(r, 'nullableID')
              } else (t.declaration = this.parseMaybeAssign()), this.semicolon()
              return this.finishNode(t, 'ExportDefaultDeclaration')
            }
            if (this.shouldParseExportStatement())
              (t.declaration = this.parseStatement(null)),
                'VariableDeclaration' === t.declaration.type
                  ? this.checkVariableExport(e, t.declaration.declarations)
                  : this.checkExport(
                      e,
                      t.declaration.id.name,
                      t.declaration.id.start
                    ),
                (t.specifiers = []),
                (t.source = null)
            else {
              if (
                ((t.declaration = null),
                (t.specifiers = this.parseExportSpecifiers(e)),
                this.eatContextual('from'))
              )
                this.type !== P.string && this.unexpected(),
                  (t.source = this.parseExprAtom())
              else {
                for (var n = 0, a = t.specifiers; n < a.length; n += 1) {
                  var o = a[n]
                  this.checkUnreserved(o.local), this.checkLocalExport(o.local)
                }
                t.source = null
              }
              this.semicolon()
            }
            return this.finishNode(t, 'ExportNamedDeclaration')
          }),
          (Z.checkExport = function (t, e, i) {
            t &&
              (F(t, e) &&
                this.raiseRecoverable(i, "Duplicate export '" + e + "'"),
              (t[e] = !0))
          }),
          (Z.checkPatternExport = function (t, e) {
            var i = e.type
            if ('Identifier' === i) this.checkExport(t, e.name, e.start)
            else if ('ObjectPattern' === i)
              for (var s = 0, r = e.properties; s < r.length; s += 1)
                this.checkPatternExport(t, r[s])
            else if ('ArrayPattern' === i)
              for (var n = 0, a = e.elements; n < a.length; n += 1) {
                var o = a[n]
                o && this.checkPatternExport(t, o)
              }
            else
              'Property' === i
                ? this.checkPatternExport(t, e.value)
                : 'AssignmentPattern' === i
                ? this.checkPatternExport(t, e.left)
                : 'RestElement' === i
                ? this.checkPatternExport(t, e.argument)
                : 'ParenthesizedExpression' === i &&
                  this.checkPatternExport(t, e.expression)
          }),
          (Z.checkVariableExport = function (t, e) {
            if (t)
              for (var i = 0, s = e; i < s.length; i += 1)
                this.checkPatternExport(t, s[i].id)
          }),
          (Z.shouldParseExportStatement = function () {
            return (
              'var' === this.type.keyword ||
              'const' === this.type.keyword ||
              'class' === this.type.keyword ||
              'function' === this.type.keyword ||
              this.isLet() ||
              this.isAsyncFunction()
            )
          }),
          (Z.parseExportSpecifiers = function (t) {
            var e = [],
              i = !0
            for (this.expect(P.braceL); !this.eat(P.braceR); ) {
              if (i) i = !1
              else if (
                (this.expect(P.comma), this.afterTrailingComma(P.braceR))
              )
                break
              var s = this.startNode()
              ;(s.local = this.parseIdent(!0)),
                (s.exported = this.eatContextual('as')
                  ? this.parseIdent(!0)
                  : s.local),
                this.checkExport(t, s.exported.name, s.exported.start),
                e.push(this.finishNode(s, 'ExportSpecifier'))
            }
            return e
          }),
          (Z.parseImport = function (t) {
            return (
              this.next(),
              this.type === P.string
                ? ((t.specifiers = et), (t.source = this.parseExprAtom()))
                : ((t.specifiers = this.parseImportSpecifiers()),
                  this.expectContextual('from'),
                  (t.source =
                    this.type === P.string
                      ? this.parseExprAtom()
                      : this.unexpected())),
              this.semicolon(),
              this.finishNode(t, 'ImportDeclaration')
            )
          }),
          (Z.parseImportSpecifiers = function () {
            var t = [],
              e = !0
            if (this.type === P.name) {
              var i = this.startNode()
              if (
                ((i.local = this.parseIdent()),
                this.checkLVal(i.local, 2),
                t.push(this.finishNode(i, 'ImportDefaultSpecifier')),
                !this.eat(P.comma))
              )
                return t
            }
            if (this.type === P.star) {
              var s = this.startNode()
              return (
                this.next(),
                this.expectContextual('as'),
                (s.local = this.parseIdent()),
                this.checkLVal(s.local, 2),
                t.push(this.finishNode(s, 'ImportNamespaceSpecifier')),
                t
              )
            }
            for (this.expect(P.braceL); !this.eat(P.braceR); ) {
              if (e) e = !1
              else if (
                (this.expect(P.comma), this.afterTrailingComma(P.braceR))
              )
                break
              var r = this.startNode()
              ;(r.imported = this.parseIdent(!0)),
                this.eatContextual('as')
                  ? (r.local = this.parseIdent())
                  : (this.checkUnreserved(r.imported), (r.local = r.imported)),
                this.checkLVal(r.local, 2),
                t.push(this.finishNode(r, 'ImportSpecifier'))
            }
            return t
          }),
          (Z.adaptDirectivePrologue = function (t) {
            for (
              var e = 0;
              e < t.length && this.isDirectiveCandidate(t[e]);
              ++e
            )
              t[e].directive = t[e].expression.raw.slice(1, -1)
          }),
          (Z.isDirectiveCandidate = function (t) {
            return (
              'ExpressionStatement' === t.type &&
              'Literal' === t.expression.type &&
              'string' == typeof t.expression.value &&
              ('"' === this.input[t.start] || "'" === this.input[t.start])
            )
          })
        var rt = H.prototype
        ;(rt.toAssignable = function (t, e, i) {
          if (this.options.ecmaVersion >= 6 && t)
            switch (t.type) {
              case 'Identifier':
                this.inAsync &&
                  'await' === t.name &&
                  this.raise(
                    t.start,
                    "Cannot use 'await' as identifier inside an async function"
                  )
                break
              case 'ObjectPattern':
              case 'ArrayPattern':
              case 'RestElement':
                break
              case 'ObjectExpression':
                ;(t.type = 'ObjectPattern'), i && this.checkPatternErrors(i, !0)
                for (var s = 0, r = t.properties; s < r.length; s += 1) {
                  var n = r[s]
                  this.toAssignable(n, e),
                    'RestElement' !== n.type ||
                      ('ArrayPattern' !== n.argument.type &&
                        'ObjectPattern' !== n.argument.type) ||
                      this.raise(n.argument.start, 'Unexpected token')
                }
                break
              case 'Property':
                'init' !== t.kind &&
                  this.raise(
                    t.key.start,
                    "Object pattern can't contain getter or setter"
                  ),
                  this.toAssignable(t.value, e)
                break
              case 'ArrayExpression':
                ;(t.type = 'ArrayPattern'),
                  i && this.checkPatternErrors(i, !0),
                  this.toAssignableList(t.elements, e)
                break
              case 'SpreadElement':
                ;(t.type = 'RestElement'),
                  this.toAssignable(t.argument, e),
                  'AssignmentPattern' === t.argument.type &&
                    this.raise(
                      t.argument.start,
                      'Rest elements cannot have a default value'
                    )
                break
              case 'AssignmentExpression':
                '=' !== t.operator &&
                  this.raise(
                    t.left.end,
                    "Only '=' operator can be used for specifying default value."
                  ),
                  (t.type = 'AssignmentPattern'),
                  delete t.operator,
                  this.toAssignable(t.left, e)
              case 'AssignmentPattern':
                break
              case 'ParenthesizedExpression':
                this.toAssignable(t.expression, e, i)
                break
              case 'MemberExpression':
                if (!e) break
              default:
                this.raise(t.start, 'Assigning to rvalue')
            }
          else i && this.checkPatternErrors(i, !0)
          return t
        }),
          (rt.toAssignableList = function (t, e) {
            for (var i = t.length, s = 0; s < i; s++) {
              var r = t[s]
              r && this.toAssignable(r, e)
            }
            if (i) {
              var n = t[i - 1]
              6 === this.options.ecmaVersion &&
                e &&
                n &&
                'RestElement' === n.type &&
                'Identifier' !== n.argument.type &&
                this.unexpected(n.argument.start)
            }
            return t
          }),
          (rt.parseSpread = function (t) {
            var e = this.startNode()
            return (
              this.next(),
              (e.argument = this.parseMaybeAssign(!1, t)),
              this.finishNode(e, 'SpreadElement')
            )
          }),
          (rt.parseRestBinding = function () {
            var t = this.startNode()
            return (
              this.next(),
              6 === this.options.ecmaVersion &&
                this.type !== P.name &&
                this.unexpected(),
              (t.argument = this.parseBindingAtom()),
              this.finishNode(t, 'RestElement')
            )
          }),
          (rt.parseBindingAtom = function () {
            if (this.options.ecmaVersion >= 6)
              switch (this.type) {
                case P.bracketL:
                  var t = this.startNode()
                  return (
                    this.next(),
                    (t.elements = this.parseBindingList(P.bracketR, !0, !0)),
                    this.finishNode(t, 'ArrayPattern')
                  )
                case P.braceL:
                  return this.parseObj(!0)
              }
            return this.parseIdent()
          }),
          (rt.parseBindingList = function (t, e, i) {
            for (var s = [], r = !0; !this.eat(t); )
              if (
                (r ? (r = !1) : this.expect(P.comma),
                e && this.type === P.comma)
              )
                s.push(null)
              else {
                if (i && this.afterTrailingComma(t)) break
                if (this.type === P.ellipsis) {
                  var n = this.parseRestBinding()
                  this.parseBindingListItem(n),
                    s.push(n),
                    this.type === P.comma &&
                      this.raise(
                        this.start,
                        'Comma is not permitted after the rest element'
                      ),
                    this.expect(t)
                  break
                }
                var a = this.parseMaybeDefault(this.start, this.startLoc)
                this.parseBindingListItem(a), s.push(a)
              }
            return s
          }),
          (rt.parseBindingListItem = function (t) {
            return t
          }),
          (rt.parseMaybeDefault = function (t, e, i) {
            if (
              ((i = i || this.parseBindingAtom()),
              this.options.ecmaVersion < 6 || !this.eat(P.eq))
            )
              return i
            var s = this.startNodeAt(t, e)
            return (
              (s.left = i),
              (s.right = this.parseMaybeAssign()),
              this.finishNode(s, 'AssignmentPattern')
            )
          }),
          (rt.checkLVal = function (t, e, i) {
            switch ((void 0 === e && (e = 0), t.type)) {
              case 'Identifier':
                this.strict &&
                  this.reservedWordsStrictBind.test(t.name) &&
                  this.raiseRecoverable(
                    t.start,
                    (e ? 'Binding ' : 'Assigning to ') +
                      t.name +
                      ' in strict mode'
                  ),
                  i &&
                    (F(i, t.name) &&
                      this.raiseRecoverable(t.start, 'Argument name clash'),
                    (i[t.name] = !0)),
                  0 !== e && 5 !== e && this.declareName(t.name, e, t.start)
                break
              case 'MemberExpression':
                e && this.raiseRecoverable(t.start, 'Binding member expression')
                break
              case 'ObjectPattern':
                for (var s = 0, r = t.properties; s < r.length; s += 1)
                  this.checkLVal(r[s], e, i)
                break
              case 'Property':
                this.checkLVal(t.value, e, i)
                break
              case 'ArrayPattern':
                for (var n = 0, a = t.elements; n < a.length; n += 1) {
                  var o = a[n]
                  o && this.checkLVal(o, e, i)
                }
                break
              case 'AssignmentPattern':
                this.checkLVal(t.left, e, i)
                break
              case 'RestElement':
                this.checkLVal(t.argument, e, i)
                break
              case 'ParenthesizedExpression':
                this.checkLVal(t.expression, e, i)
                break
              default:
                this.raise(
                  t.start,
                  (e ? 'Binding' : 'Assigning to') + ' rvalue'
                )
            }
          })
        var nt = H.prototype
        ;(nt.checkPropClash = function (t, e, i) {
          if (
            !(
              (this.options.ecmaVersion >= 9 && 'SpreadElement' === t.type) ||
              (this.options.ecmaVersion >= 6 &&
                (t.computed || t.method || t.shorthand))
            )
          ) {
            var s,
              r = t.key
            switch (r.type) {
              case 'Identifier':
                s = r.name
                break
              case 'Literal':
                s = String(r.value)
                break
              default:
                return
            }
            var n = t.kind
            if (this.options.ecmaVersion >= 6)
              '__proto__' === s &&
                'init' === n &&
                (e.proto &&
                  (i && i.doubleProto < 0
                    ? (i.doubleProto = r.start)
                    : this.raiseRecoverable(
                        r.start,
                        'Redefinition of __proto__ property'
                      )),
                (e.proto = !0))
            else {
              var a = e[(s = '$' + s)]
              a
                ? ('init' === n
                    ? (this.strict && a.init) || a.get || a.set
                    : a.init || a[n]) &&
                  this.raiseRecoverable(r.start, 'Redefinition of property')
                : (a = e[s] = { init: !1, get: !1, set: !1 }),
                (a[n] = !0)
            }
          }
        }),
          (nt.parseExpression = function (t, e) {
            var i = this.start,
              s = this.startLoc,
              r = this.parseMaybeAssign(t, e)
            if (this.type === P.comma) {
              var n = this.startNodeAt(i, s)
              for (n.expressions = [r]; this.eat(P.comma); )
                n.expressions.push(this.parseMaybeAssign(t, e))
              return this.finishNode(n, 'SequenceExpression')
            }
            return r
          }),
          (nt.parseMaybeAssign = function (t, e, i) {
            if (this.isContextual('yield')) {
              if (this.inGenerator) return this.parseYield(t)
              this.exprAllowed = !1
            }
            var s = !1,
              r = -1,
              n = -1,
              a = -1
            e
              ? ((r = e.parenthesizedAssign),
                (n = e.trailingComma),
                (a = e.shorthandAssign),
                (e.parenthesizedAssign = e.trailingComma = e.shorthandAssign = -1))
              : ((e = new $()), (s = !0))
            var o = this.start,
              p = this.startLoc
            ;(this.type !== P.parenL && this.type !== P.name) ||
              (this.potentialArrowAt = this.start)
            var h = this.parseMaybeConditional(t, e)
            if ((i && (h = i.call(this, h, o, p)), this.type.isAssign)) {
              var c = this.startNodeAt(o, p)
              return (
                (c.operator = this.value),
                (c.left = this.type === P.eq ? this.toAssignable(h, !1, e) : h),
                s || $.call(e),
                (e.shorthandAssign = -1),
                this.checkLVal(h),
                this.next(),
                (c.right = this.parseMaybeAssign(t)),
                this.finishNode(c, 'AssignmentExpression')
              )
            }
            return (
              s && this.checkExpressionErrors(e, !0),
              r > -1 && (e.parenthesizedAssign = r),
              n > -1 && (e.trailingComma = n),
              a > -1 && (e.shorthandAssign = a),
              h
            )
          }),
          (nt.parseMaybeConditional = function (t, e) {
            var i = this.start,
              s = this.startLoc,
              r = this.parseExprOps(t, e)
            if (this.checkExpressionErrors(e)) return r
            if (this.eat(P.question)) {
              var n = this.startNodeAt(i, s)
              return (
                (n.test = r),
                (n.consequent = this.parseMaybeAssign()),
                this.expect(P.colon),
                (n.alternate = this.parseMaybeAssign(t)),
                this.finishNode(n, 'ConditionalExpression')
              )
            }
            return r
          }),
          (nt.parseExprOps = function (t, e) {
            var i = this.start,
              s = this.startLoc,
              r = this.parseMaybeUnary(e, !1)
            return this.checkExpressionErrors(e) ||
              (r.start === i && 'ArrowFunctionExpression' === r.type)
              ? r
              : this.parseExprOp(r, i, s, -1, t)
          }),
          (nt.parseExprOp = function (t, e, i, s, r) {
            var n = this.type.binop
            if (null != n && (!r || this.type !== P._in) && n > s) {
              var a = this.type === P.logicalOR || this.type === P.logicalAND,
                o = this.value
              this.next()
              var p = this.start,
                h = this.startLoc,
                c = this.parseExprOp(
                  this.parseMaybeUnary(null, !1),
                  p,
                  h,
                  n,
                  r
                ),
                l = this.buildBinary(e, i, t, c, o, a)
              return this.parseExprOp(l, e, i, s, r)
            }
            return t
          }),
          (nt.buildBinary = function (t, e, i, s, r, n) {
            var a = this.startNodeAt(t, e)
            return (
              (a.left = i),
              (a.operator = r),
              (a.right = s),
              this.finishNode(a, n ? 'LogicalExpression' : 'BinaryExpression')
            )
          }),
          (nt.parseMaybeUnary = function (t, e) {
            var i,
              s = this.start,
              r = this.startLoc
            if (
              this.isContextual('await') &&
              (this.inAsync ||
                (!this.inFunction && this.options.allowAwaitOutsideFunction))
            )
              (i = this.parseAwait()), (e = !0)
            else if (this.type.prefix) {
              var n = this.startNode(),
                a = this.type === P.incDec
              ;(n.operator = this.value),
                (n.prefix = !0),
                this.next(),
                (n.argument = this.parseMaybeUnary(null, !0)),
                this.checkExpressionErrors(t, !0),
                a
                  ? this.checkLVal(n.argument)
                  : this.strict &&
                    'delete' === n.operator &&
                    'Identifier' === n.argument.type
                  ? this.raiseRecoverable(
                      n.start,
                      'Deleting local variable in strict mode'
                    )
                  : (e = !0),
                (i = this.finishNode(
                  n,
                  a ? 'UpdateExpression' : 'UnaryExpression'
                ))
            } else {
              if (
                ((i = this.parseExprSubscripts(t)),
                this.checkExpressionErrors(t))
              )
                return i
              for (; this.type.postfix && !this.canInsertSemicolon(); ) {
                var o = this.startNodeAt(s, r)
                ;(o.operator = this.value),
                  (o.prefix = !1),
                  (o.argument = i),
                  this.checkLVal(i),
                  this.next(),
                  (i = this.finishNode(o, 'UpdateExpression'))
              }
            }
            return !e && this.eat(P.starstar)
              ? this.buildBinary(
                  s,
                  r,
                  i,
                  this.parseMaybeUnary(null, !1),
                  '**',
                  !1
                )
              : i
          }),
          (nt.parseExprSubscripts = function (t) {
            var e = this.start,
              i = this.startLoc,
              s = this.parseExprAtom(t),
              r =
                'ArrowFunctionExpression' === s.type &&
                ')' !== this.input.slice(this.lastTokStart, this.lastTokEnd)
            if (this.checkExpressionErrors(t) || r) return s
            var n = this.parseSubscripts(s, e, i)
            return (
              t &&
                'MemberExpression' === n.type &&
                (t.parenthesizedAssign >= n.start &&
                  (t.parenthesizedAssign = -1),
                t.parenthesizedBind >= n.start && (t.parenthesizedBind = -1)),
              n
            )
          }),
          (nt.parseSubscripts = function (t, e, i, s) {
            for (
              var r =
                this.options.ecmaVersion >= 8 &&
                'Identifier' === t.type &&
                'async' === t.name &&
                this.lastTokEnd === t.end &&
                !this.canInsertSemicolon() &&
                'async' === this.input.slice(t.start, t.end);
              ;

            ) {
              var n = this.parseSubscript(t, e, i, s, r)
              if (n === t || 'ArrowFunctionExpression' === n.type) return n
              t = n
            }
          }),
          (nt.parseSubscript = function (t, e, i, s, r) {
            var n = this.eat(P.bracketL)
            if (n || this.eat(P.dot)) {
              var a = this.startNodeAt(e, i)
              ;(a.object = t),
                (a.property = n ? this.parseExpression() : this.parseIdent(!0)),
                (a.computed = !!n),
                n && this.expect(P.bracketR),
                (t = this.finishNode(a, 'MemberExpression'))
            } else if (!s && this.eat(P.parenL)) {
              var o = new $(),
                p = this.yieldPos,
                h = this.awaitPos,
                c = this.awaitIdentPos
              ;(this.yieldPos = 0),
                (this.awaitPos = 0),
                (this.awaitIdentPos = 0)
              var l = this.parseExprList(
                P.parenR,
                this.options.ecmaVersion >= 8,
                !1,
                o
              )
              if (r && !this.canInsertSemicolon() && this.eat(P.arrow))
                return (
                  this.checkPatternErrors(o, !1),
                  this.checkYieldAwaitInDefaultParams(),
                  this.awaitIdentPos > 0 &&
                    this.raise(
                      this.awaitIdentPos,
                      "Cannot use 'await' as identifier inside an async function"
                    ),
                  (this.yieldPos = p),
                  (this.awaitPos = h),
                  (this.awaitIdentPos = c),
                  this.parseArrowExpression(this.startNodeAt(e, i), l, !0)
                )
              this.checkExpressionErrors(o, !0),
                (this.yieldPos = p || this.yieldPos),
                (this.awaitPos = h || this.awaitPos),
                (this.awaitIdentPos = c || this.awaitIdentPos)
              var u = this.startNodeAt(e, i)
              ;(u.callee = t),
                (u.arguments = l),
                (t = this.finishNode(u, 'CallExpression'))
            } else if (this.type === P.backQuote) {
              var d = this.startNodeAt(e, i)
              ;(d.tag = t),
                (d.quasi = this.parseTemplate({ isTagged: !0 })),
                (t = this.finishNode(d, 'TaggedTemplateExpression'))
            }
            return t
          }),
          (nt.parseExprAtom = function (t) {
            this.type === P.slash && this.readRegexp()
            var e,
              i = this.potentialArrowAt === this.start
            switch (this.type) {
              case P._super:
                return (
                  this.allowSuper ||
                    this.raise(this.start, "'super' keyword outside a method"),
                  (e = this.startNode()),
                  this.next(),
                  this.type !== P.parenL ||
                    this.allowDirectSuper ||
                    this.raise(
                      e.start,
                      'super() call outside constructor of a subclass'
                    ),
                  this.type !== P.dot &&
                    this.type !== P.bracketL &&
                    this.type !== P.parenL &&
                    this.unexpected(),
                  this.finishNode(e, 'Super')
                )
              case P._this:
                return (
                  (e = this.startNode()),
                  this.next(),
                  this.finishNode(e, 'ThisExpression')
                )
              case P.name:
                var s = this.start,
                  r = this.startLoc,
                  n = this.containsEsc,
                  a = this.parseIdent(!1)
                if (
                  this.options.ecmaVersion >= 8 &&
                  !n &&
                  'async' === a.name &&
                  !this.canInsertSemicolon() &&
                  this.eat(P._function)
                )
                  return this.parseFunction(this.startNodeAt(s, r), 0, !1, !0)
                if (i && !this.canInsertSemicolon()) {
                  if (this.eat(P.arrow))
                    return this.parseArrowExpression(
                      this.startNodeAt(s, r),
                      [a],
                      !1
                    )
                  if (
                    this.options.ecmaVersion >= 8 &&
                    'async' === a.name &&
                    this.type === P.name &&
                    !n
                  )
                    return (
                      (a = this.parseIdent(!1)),
                      (!this.canInsertSemicolon() && this.eat(P.arrow)) ||
                        this.unexpected(),
                      this.parseArrowExpression(this.startNodeAt(s, r), [a], !0)
                    )
                }
                return a
              case P.regexp:
                var o = this.value
                return (
                  ((e = this.parseLiteral(o.value)).regex = {
                    pattern: o.pattern,
                    flags: o.flags,
                  }),
                  e
                )
              case P.num:
              case P.string:
                return this.parseLiteral(this.value)
              case P._null:
              case P._true:
              case P._false:
                return (
                  ((e = this.startNode()).value =
                    this.type === P._null ? null : this.type === P._true),
                  (e.raw = this.type.keyword),
                  this.next(),
                  this.finishNode(e, 'Literal')
                )
              case P.parenL:
                var p = this.start,
                  h = this.parseParenAndDistinguishExpression(i)
                return (
                  t &&
                    (t.parenthesizedAssign < 0 &&
                      !this.isSimpleAssignTarget(h) &&
                      (t.parenthesizedAssign = p),
                    t.parenthesizedBind < 0 && (t.parenthesizedBind = p)),
                  h
                )
              case P.bracketL:
                return (
                  (e = this.startNode()),
                  this.next(),
                  (e.elements = this.parseExprList(P.bracketR, !0, !0, t)),
                  this.finishNode(e, 'ArrayExpression')
                )
              case P.braceL:
                return this.parseObj(!1, t)
              case P._function:
                return (
                  (e = this.startNode()), this.next(), this.parseFunction(e, 0)
                )
              case P._class:
                return this.parseClass(this.startNode(), !1)
              case P._new:
                return this.parseNew()
              case P.backQuote:
                return this.parseTemplate()
              default:
                this.unexpected()
            }
          }),
          (nt.parseLiteral = function (t) {
            var e = this.startNode()
            return (
              (e.value = t),
              (e.raw = this.input.slice(this.start, this.end)),
              this.next(),
              this.finishNode(e, 'Literal')
            )
          }),
          (nt.parseParenExpression = function () {
            this.expect(P.parenL)
            var t = this.parseExpression()
            return this.expect(P.parenR), t
          }),
          (nt.parseParenAndDistinguishExpression = function (t) {
            var e,
              i = this.start,
              s = this.startLoc,
              r = this.options.ecmaVersion >= 8
            if (this.options.ecmaVersion >= 6) {
              this.next()
              var n,
                a = this.start,
                o = this.startLoc,
                p = [],
                h = !0,
                c = !1,
                l = new $(),
                u = this.yieldPos,
                d = this.awaitPos
              for (
                this.yieldPos = 0, this.awaitPos = 0;
                this.type !== P.parenR;

              ) {
                if (
                  (h ? (h = !1) : this.expect(P.comma),
                  r && this.afterTrailingComma(P.parenR, !0))
                ) {
                  c = !0
                  break
                }
                if (this.type === P.ellipsis) {
                  ;(n = this.start),
                    p.push(this.parseParenItem(this.parseRestBinding())),
                    this.type === P.comma &&
                      this.raise(
                        this.start,
                        'Comma is not permitted after the rest element'
                      )
                  break
                }
                p.push(this.parseMaybeAssign(!1, l, this.parseParenItem))
              }
              var f = this.start,
                m = this.startLoc
              if (
                (this.expect(P.parenR),
                t && !this.canInsertSemicolon() && this.eat(P.arrow))
              )
                return (
                  this.checkPatternErrors(l, !1),
                  this.checkYieldAwaitInDefaultParams(),
                  (this.yieldPos = u),
                  (this.awaitPos = d),
                  this.parseParenArrowList(i, s, p)
                )
              ;(p.length && !c) || this.unexpected(this.lastTokStart),
                n && this.unexpected(n),
                this.checkExpressionErrors(l, !0),
                (this.yieldPos = u || this.yieldPos),
                (this.awaitPos = d || this.awaitPos),
                p.length > 1
                  ? (((e = this.startNodeAt(a, o)).expressions = p),
                    this.finishNodeAt(e, 'SequenceExpression', f, m))
                  : (e = p[0])
            } else e = this.parseParenExpression()
            if (this.options.preserveParens) {
              var y = this.startNodeAt(i, s)
              return (
                (y.expression = e),
                this.finishNode(y, 'ParenthesizedExpression')
              )
            }
            return e
          }),
          (nt.parseParenItem = function (t) {
            return t
          }),
          (nt.parseParenArrowList = function (t, e, i) {
            return this.parseArrowExpression(this.startNodeAt(t, e), i)
          })
        var at = []
        ;(nt.parseNew = function () {
          var t = this.startNode(),
            e = this.parseIdent(!0)
          if (this.options.ecmaVersion >= 6 && this.eat(P.dot)) {
            t.meta = e
            var i = this.containsEsc
            return (
              (t.property = this.parseIdent(!0)),
              ('target' !== t.property.name || i) &&
                this.raiseRecoverable(
                  t.property.start,
                  'The only valid meta property for new is new.target'
                ),
              this.inNonArrowFunction() ||
                this.raiseRecoverable(
                  t.start,
                  'new.target can only be used in functions'
                ),
              this.finishNode(t, 'MetaProperty')
            )
          }
          var s = this.start,
            r = this.startLoc
          return (
            (t.callee = this.parseSubscripts(this.parseExprAtom(), s, r, !0)),
            (t.arguments = this.eat(P.parenL)
              ? this.parseExprList(P.parenR, this.options.ecmaVersion >= 8, !1)
              : at),
            this.finishNode(t, 'NewExpression')
          )
        }),
          (nt.parseTemplateElement = function (t) {
            var e = t.isTagged,
              i = this.startNode()
            return (
              this.type === P.invalidTemplate
                ? (e ||
                    this.raiseRecoverable(
                      this.start,
                      'Bad escape sequence in untagged template literal'
                    ),
                  (i.value = { raw: this.value, cooked: null }))
                : (i.value = {
                    raw: this.input
                      .slice(this.start, this.end)
                      .replace(/\r\n?/g, '\n'),
                    cooked: this.value,
                  }),
              this.next(),
              (i.tail = this.type === P.backQuote),
              this.finishNode(i, 'TemplateElement')
            )
          }),
          (nt.parseTemplate = function (t) {
            void 0 === t && (t = {})
            var e = t.isTagged
            void 0 === e && (e = !1)
            var i = this.startNode()
            this.next(), (i.expressions = [])
            var s = this.parseTemplateElement({ isTagged: e })
            for (i.quasis = [s]; !s.tail; )
              this.type === P.eof &&
                this.raise(this.pos, 'Unterminated template literal'),
                this.expect(P.dollarBraceL),
                i.expressions.push(this.parseExpression()),
                this.expect(P.braceR),
                i.quasis.push((s = this.parseTemplateElement({ isTagged: e })))
            return this.next(), this.finishNode(i, 'TemplateLiteral')
          }),
          (nt.isAsyncProp = function (t) {
            return (
              !t.computed &&
              'Identifier' === t.key.type &&
              'async' === t.key.name &&
              (this.type === P.name ||
                this.type === P.num ||
                this.type === P.string ||
                this.type === P.bracketL ||
                this.type.keyword ||
                (this.options.ecmaVersion >= 9 && this.type === P.star)) &&
              !N.test(this.input.slice(this.lastTokEnd, this.start))
            )
          }),
          (nt.parseObj = function (t, e) {
            var i = this.startNode(),
              s = !0,
              r = {}
            for (i.properties = [], this.next(); !this.eat(P.braceR); ) {
              if (s) s = !1
              else if (
                (this.expect(P.comma), this.afterTrailingComma(P.braceR))
              )
                break
              var n = this.parseProperty(t, e)
              t || this.checkPropClash(n, r, e), i.properties.push(n)
            }
            return this.finishNode(i, t ? 'ObjectPattern' : 'ObjectExpression')
          }),
          (nt.parseProperty = function (t, e) {
            var i,
              s,
              r,
              n,
              a = this.startNode()
            if (this.options.ecmaVersion >= 9 && this.eat(P.ellipsis))
              return t
                ? ((a.argument = this.parseIdent(!1)),
                  this.type === P.comma &&
                    this.raise(
                      this.start,
                      'Comma is not permitted after the rest element'
                    ),
                  this.finishNode(a, 'RestElement'))
                : (this.type === P.parenL &&
                    e &&
                    (e.parenthesizedAssign < 0 &&
                      (e.parenthesizedAssign = this.start),
                    e.parenthesizedBind < 0 &&
                      (e.parenthesizedBind = this.start)),
                  (a.argument = this.parseMaybeAssign(!1, e)),
                  this.type === P.comma &&
                    e &&
                    e.trailingComma < 0 &&
                    (e.trailingComma = this.start),
                  this.finishNode(a, 'SpreadElement'))
            this.options.ecmaVersion >= 6 &&
              ((a.method = !1),
              (a.shorthand = !1),
              (t || e) && ((r = this.start), (n = this.startLoc)),
              t || (i = this.eat(P.star)))
            var o = this.containsEsc
            return (
              this.parsePropertyName(a),
              !t &&
              !o &&
              this.options.ecmaVersion >= 8 &&
              !i &&
              this.isAsyncProp(a)
                ? ((s = !0),
                  (i = this.options.ecmaVersion >= 9 && this.eat(P.star)),
                  this.parsePropertyName(a, e))
                : (s = !1),
              this.parsePropertyValue(a, t, i, s, r, n, e, o),
              this.finishNode(a, 'Property')
            )
          }),
          (nt.parsePropertyValue = function (t, e, i, s, r, n, a, o) {
            ;(i || s) && this.type === P.colon && this.unexpected(),
              this.eat(P.colon)
                ? ((t.value = e
                    ? this.parseMaybeDefault(this.start, this.startLoc)
                    : this.parseMaybeAssign(!1, a)),
                  (t.kind = 'init'))
                : this.options.ecmaVersion >= 6 && this.type === P.parenL
                ? (e && this.unexpected(),
                  (t.kind = 'init'),
                  (t.method = !0),
                  (t.value = this.parseMethod(i, s)))
                : e ||
                  o ||
                  !(this.options.ecmaVersion >= 5) ||
                  t.computed ||
                  'Identifier' !== t.key.type ||
                  ('get' !== t.key.name && 'set' !== t.key.name) ||
                  this.type === P.comma ||
                  this.type === P.braceR
                ? this.options.ecmaVersion >= 6 &&
                  !t.computed &&
                  'Identifier' === t.key.type
                  ? ((i || s) && this.unexpected(),
                    this.checkUnreserved(t.key),
                    'await' !== t.key.name ||
                      this.awaitIdentPos ||
                      (this.awaitIdentPos = r),
                    (t.kind = 'init'),
                    e
                      ? (t.value = this.parseMaybeDefault(r, n, t.key))
                      : this.type === P.eq && a
                      ? (a.shorthandAssign < 0 &&
                          (a.shorthandAssign = this.start),
                        (t.value = this.parseMaybeDefault(r, n, t.key)))
                      : (t.value = t.key),
                    (t.shorthand = !0))
                  : this.unexpected()
                : ((i || s) && this.unexpected(),
                  (t.kind = t.key.name),
                  this.parsePropertyName(t),
                  (t.value = this.parseMethod(!1)),
                  t.value.params.length !== ('get' === t.kind ? 0 : 1)
                    ? this.raiseRecoverable(
                        t.value.start,
                        'get' === t.kind
                          ? 'getter should have no params'
                          : 'setter should have exactly one param'
                      )
                    : 'set' === t.kind &&
                      'RestElement' === t.value.params[0].type &&
                      this.raiseRecoverable(
                        t.value.params[0].start,
                        'Setter cannot use rest params'
                      ))
          }),
          (nt.parsePropertyName = function (t) {
            if (this.options.ecmaVersion >= 6) {
              if (this.eat(P.bracketL))
                return (
                  (t.computed = !0),
                  (t.key = this.parseMaybeAssign()),
                  this.expect(P.bracketR),
                  t.key
                )
              t.computed = !1
            }
            return (t.key =
              this.type === P.num || this.type === P.string
                ? this.parseExprAtom()
                : this.parseIdent(!0))
          }),
          (nt.initFunction = function (t) {
            ;(t.id = null),
              this.options.ecmaVersion >= 6 &&
                (t.generator = t.expression = !1),
              this.options.ecmaVersion >= 8 && (t.async = !1)
          }),
          (nt.parseMethod = function (t, e, i) {
            var s = this.startNode(),
              r = this.yieldPos,
              n = this.awaitPos,
              a = this.awaitIdentPos
            return (
              this.initFunction(s),
              this.options.ecmaVersion >= 6 && (s.generator = t),
              this.options.ecmaVersion >= 8 && (s.async = !!e),
              (this.yieldPos = 0),
              (this.awaitPos = 0),
              (this.awaitIdentPos = 0),
              this.enterScope(64 | W(e, s.generator) | (i ? 128 : 0)),
              this.expect(P.parenL),
              (s.params = this.parseBindingList(
                P.parenR,
                !1,
                this.options.ecmaVersion >= 8
              )),
              this.checkYieldAwaitInDefaultParams(),
              this.parseFunctionBody(s, !1, !0),
              (this.yieldPos = r),
              (this.awaitPos = n),
              (this.awaitIdentPos = a),
              this.finishNode(s, 'FunctionExpression')
            )
          }),
          (nt.parseArrowExpression = function (t, e, i) {
            var s = this.yieldPos,
              r = this.awaitPos,
              n = this.awaitIdentPos
            return (
              this.enterScope(16 | W(i, !1)),
              this.initFunction(t),
              this.options.ecmaVersion >= 8 && (t.async = !!i),
              (this.yieldPos = 0),
              (this.awaitPos = 0),
              (this.awaitIdentPos = 0),
              (t.params = this.toAssignableList(e, !0)),
              this.parseFunctionBody(t, !0, !1),
              (this.yieldPos = s),
              (this.awaitPos = r),
              (this.awaitIdentPos = n),
              this.finishNode(t, 'ArrowFunctionExpression')
            )
          }),
          (nt.parseFunctionBody = function (t, e, i) {
            var s = this.strict,
              r = !1
            if (e && this.type !== P.braceL)
              (t.body = this.parseMaybeAssign()),
                (t.expression = !0),
                this.checkParams(t, !1)
            else {
              var n =
                this.options.ecmaVersion >= 7 &&
                !this.isSimpleParamList(t.params)
              ;(s && !n) ||
                ((r = this.strictDirective(this.end)) &&
                  n &&
                  this.raiseRecoverable(
                    t.start,
                    "Illegal 'use strict' directive in function with non-simple parameter list"
                  ))
              var a = this.labels
              ;(this.labels = []),
                r && (this.strict = !0),
                this.checkParams(
                  t,
                  !s && !r && !e && !i && this.isSimpleParamList(t.params)
                ),
                (t.body = this.parseBlock(!1)),
                (t.expression = !1),
                this.adaptDirectivePrologue(t.body.body),
                (this.labels = a)
            }
            this.exitScope(),
              this.strict && t.id && this.checkLVal(t.id, 5),
              (this.strict = s)
          }),
          (nt.isSimpleParamList = function (t) {
            for (var e = 0, i = t; e < i.length; e += 1)
              if ('Identifier' !== i[e].type) return !1
            return !0
          }),
          (nt.checkParams = function (t, e) {
            for (var i = {}, s = 0, r = t.params; s < r.length; s += 1)
              this.checkLVal(r[s], 1, e ? null : i)
          }),
          (nt.parseExprList = function (t, e, i, s) {
            for (var r = [], n = !0; !this.eat(t); ) {
              if (n) n = !1
              else if ((this.expect(P.comma), e && this.afterTrailingComma(t)))
                break
              var a = void 0
              i && this.type === P.comma
                ? (a = null)
                : this.type === P.ellipsis
                ? ((a = this.parseSpread(s)),
                  s &&
                    this.type === P.comma &&
                    s.trailingComma < 0 &&
                    (s.trailingComma = this.start))
                : (a = this.parseMaybeAssign(!1, s)),
                r.push(a)
            }
            return r
          }),
          (nt.checkUnreserved = function (t) {
            var e = t.start,
              i = t.end,
              s = t.name
            this.inGenerator &&
              'yield' === s &&
              this.raiseRecoverable(
                e,
                "Cannot use 'yield' as identifier inside a generator"
              ),
              this.inAsync &&
                'await' === s &&
                this.raiseRecoverable(
                  e,
                  "Cannot use 'await' as identifier inside an async function"
                ),
              this.keywords.test(s) &&
                this.raise(e, "Unexpected keyword '" + s + "'"),
              (this.options.ecmaVersion < 6 &&
                -1 !== this.input.slice(e, i).indexOf('\\')) ||
                ((this.strict
                  ? this.reservedWordsStrict
                  : this.reservedWords
                ).test(s) &&
                  (this.inAsync ||
                    'await' !== s ||
                    this.raiseRecoverable(
                      e,
                      "Cannot use keyword 'await' outside an async function"
                    ),
                  this.raiseRecoverable(
                    e,
                    "The keyword '" + s + "' is reserved"
                  )))
          }),
          (nt.parseIdent = function (t, e) {
            var i = this.startNode()
            return (
              t && 'never' === this.options.allowReserved && (t = !1),
              this.type === P.name
                ? (i.name = this.value)
                : this.type.keyword
                ? ((i.name = this.type.keyword),
                  ('class' !== i.name && 'function' !== i.name) ||
                    (this.lastTokEnd === this.lastTokStart + 1 &&
                      46 === this.input.charCodeAt(this.lastTokStart)) ||
                    this.context.pop())
                : this.unexpected(),
              this.next(),
              this.finishNode(i, 'Identifier'),
              t ||
                (this.checkUnreserved(i),
                'await' !== i.name ||
                  this.awaitIdentPos ||
                  (this.awaitIdentPos = i.start)),
              i
            )
          }),
          (nt.parseYield = function (t) {
            this.yieldPos || (this.yieldPos = this.start)
            var e = this.startNode()
            return (
              this.next(),
              this.type === P.semi ||
              this.canInsertSemicolon() ||
              (this.type !== P.star && !this.type.startsExpr)
                ? ((e.delegate = !1), (e.argument = null))
                : ((e.delegate = this.eat(P.star)),
                  (e.argument = this.parseMaybeAssign(t))),
              this.finishNode(e, 'YieldExpression')
            )
          }),
          (nt.parseAwait = function () {
            this.awaitPos || (this.awaitPos = this.start)
            var t = this.startNode()
            return (
              this.next(),
              (t.argument = this.parseMaybeUnary(null, !0)),
              this.finishNode(t, 'AwaitExpression')
            )
          })
        var ot = H.prototype
        ;(ot.raise = function (t, e) {
          var i = X(this.input, t),
            s = new SyntaxError((e += ' (' + i.line + ':' + i.column + ')'))
          throw ((s.pos = t), (s.loc = i), (s.raisedAt = this.pos), s)
        }),
          (ot.raiseRecoverable = ot.raise),
          (ot.curPosition = function () {
            if (this.options.locations)
              return new q(this.curLine, this.pos - this.lineStart)
          })
        var pt = H.prototype,
          ht = function (t) {
            ;(this.flags = t),
              (this.var = []),
              (this.lexical = []),
              (this.functions = [])
          }
        ;(pt.enterScope = function (t) {
          this.scopeStack.push(new ht(t))
        }),
          (pt.exitScope = function () {
            this.scopeStack.pop()
          }),
          (pt.treatFunctionsAsVarInScope = function (t) {
            return 2 & t.flags || (!this.inModule && 1 & t.flags)
          }),
          (pt.declareName = function (t, e, i) {
            var s = !1
            if (2 === e) {
              var r = this.currentScope()
              ;(s =
                r.lexical.indexOf(t) > -1 ||
                r.functions.indexOf(t) > -1 ||
                r.var.indexOf(t) > -1),
                r.lexical.push(t),
                this.inModule && 1 & r.flags && delete this.undefinedExports[t]
            } else if (4 === e) this.currentScope().lexical.push(t)
            else if (3 === e) {
              var n = this.currentScope()
              ;(s = this.treatFunctionsAsVar
                ? n.lexical.indexOf(t) > -1
                : n.lexical.indexOf(t) > -1 || n.var.indexOf(t) > -1),
                n.functions.push(t)
            } else
              for (var a = this.scopeStack.length - 1; a >= 0; --a) {
                var o = this.scopeStack[a]
                if (
                  (o.lexical.indexOf(t) > -1 &&
                    !(32 & o.flags && o.lexical[0] === t)) ||
                  (!this.treatFunctionsAsVarInScope(o) &&
                    o.functions.indexOf(t) > -1)
                ) {
                  s = !0
                  break
                }
                if (
                  (o.var.push(t),
                  this.inModule &&
                    1 & o.flags &&
                    delete this.undefinedExports[t],
                  3 & o.flags)
                )
                  break
              }
            s &&
              this.raiseRecoverable(
                i,
                "Identifier '" + t + "' has already been declared"
              )
          }),
          (pt.checkLocalExport = function (t) {
            ;-1 === this.scopeStack[0].lexical.indexOf(t.name) &&
              -1 === this.scopeStack[0].var.indexOf(t.name) &&
              (this.undefinedExports[t.name] = t)
          }),
          (pt.currentScope = function () {
            return this.scopeStack[this.scopeStack.length - 1]
          }),
          (pt.currentVarScope = function () {
            for (var t = this.scopeStack.length - 1; ; t--) {
              var e = this.scopeStack[t]
              if (3 & e.flags) return e
            }
          }),
          (pt.currentThisScope = function () {
            for (var t = this.scopeStack.length - 1; ; t--) {
              var e = this.scopeStack[t]
              if (3 & e.flags && !(16 & e.flags)) return e
            }
          })
        var ct = function (t, e, i) {
            ;(this.type = ''),
              (this.start = e),
              (this.end = 0),
              t.options.locations && (this.loc = new J(t, i)),
              t.options.directSourceFile &&
                (this.sourceFile = t.options.directSourceFile),
              t.options.ranges && (this.range = [e, 0])
          },
          lt = H.prototype
        function ut(t, e, i, s) {
          return (
            (t.type = e),
            (t.end = i),
            this.options.locations && (t.loc.end = s),
            this.options.ranges && (t.range[1] = i),
            t
          )
        }
        ;(lt.startNode = function () {
          return new ct(this, this.start, this.startLoc)
        }),
          (lt.startNodeAt = function (t, e) {
            return new ct(this, t, e)
          }),
          (lt.finishNode = function (t, e) {
            return ut.call(this, t, e, this.lastTokEnd, this.lastTokEndLoc)
          }),
          (lt.finishNodeAt = function (t, e, i, s) {
            return ut.call(this, t, e, i, s)
          })
        var dt = function (t, e, i, s, r) {
            ;(this.token = t),
              (this.isExpr = !!e),
              (this.preserveSpace = !!i),
              (this.override = s),
              (this.generator = !!r)
          },
          ft = {
            b_stat: new dt('{', !1),
            b_expr: new dt('{', !0),
            b_tmpl: new dt('${', !1),
            p_stat: new dt('(', !1),
            p_expr: new dt('(', !0),
            q_tmpl: new dt('`', !0, !0, function (t) {
              return t.tryReadTemplateToken()
            }),
            f_stat: new dt('function', !1),
            f_expr: new dt('function', !0),
            f_expr_gen: new dt('function', !0, !1, null, !0),
            f_gen: new dt('function', !1, !1, null, !0),
          },
          mt = H.prototype
        ;(mt.initialContext = function () {
          return [ft.b_stat]
        }),
          (mt.braceIsBlock = function (t) {
            var e = this.curContext()
            return (
              e === ft.f_expr ||
              e === ft.f_stat ||
              (t !== P.colon || (e !== ft.b_stat && e !== ft.b_expr)
                ? t === P._return || (t === P.name && this.exprAllowed)
                  ? N.test(this.input.slice(this.lastTokEnd, this.start))
                  : t === P._else ||
                    t === P.semi ||
                    t === P.eof ||
                    t === P.parenR ||
                    t === P.arrow ||
                    (t === P.braceL
                      ? e === ft.b_stat
                      : t !== P._var &&
                        t !== P._const &&
                        t !== P.name &&
                        !this.exprAllowed)
                : !e.isExpr)
            )
          }),
          (mt.inGeneratorContext = function () {
            for (var t = this.context.length - 1; t >= 1; t--) {
              var e = this.context[t]
              if ('function' === e.token) return e.generator
            }
            return !1
          }),
          (mt.updateContext = function (t) {
            var e,
              i = this.type
            i.keyword && t === P.dot
              ? (this.exprAllowed = !1)
              : (e = i.updateContext)
              ? e.call(this, t)
              : (this.exprAllowed = i.beforeExpr)
          }),
          (P.parenR.updateContext = P.braceR.updateContext = function () {
            if (1 !== this.context.length) {
              var t = this.context.pop()
              t === ft.b_stat &&
                'function' === this.curContext().token &&
                (t = this.context.pop()),
                (this.exprAllowed = !t.isExpr)
            } else this.exprAllowed = !0
          }),
          (P.braceL.updateContext = function (t) {
            this.context.push(this.braceIsBlock(t) ? ft.b_stat : ft.b_expr),
              (this.exprAllowed = !0)
          }),
          (P.dollarBraceL.updateContext = function () {
            this.context.push(ft.b_tmpl), (this.exprAllowed = !0)
          }),
          (P.parenL.updateContext = function (t) {
            this.context.push(
              t === P._if || t === P._for || t === P._with || t === P._while
                ? ft.p_stat
                : ft.p_expr
            ),
              (this.exprAllowed = !0)
          }),
          (P.incDec.updateContext = function () {}),
          (P._function.updateContext = P._class.updateContext = function (t) {
            !t.beforeExpr ||
            t === P.semi ||
            t === P._else ||
            (t === P._return &&
              N.test(this.input.slice(this.lastTokEnd, this.start))) ||
            ((t === P.colon || t === P.braceL) &&
              this.curContext() === ft.b_stat)
              ? this.context.push(ft.f_stat)
              : this.context.push(ft.f_expr),
              (this.exprAllowed = !1)
          }),
          (P.backQuote.updateContext = function () {
            this.curContext() === ft.q_tmpl
              ? this.context.pop()
              : this.context.push(ft.q_tmpl),
              (this.exprAllowed = !1)
          }),
          (P.star.updateContext = function (t) {
            if (t === P._function) {
              var e = this.context.length - 1
              this.context[e] =
                this.context[e] === ft.f_expr ? ft.f_expr_gen : ft.f_gen
            }
            this.exprAllowed = !0
          }),
          (P.name.updateContext = function (t) {
            var e = !1
            this.options.ecmaVersion >= 6 &&
              t !== P.dot &&
              (('of' === this.value && !this.exprAllowed) ||
                ('yield' === this.value && this.inGeneratorContext())) &&
              (e = !0),
              (this.exprAllowed = e)
          })
        var yt =
            'ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS',
          gt = { 9: yt, 10: yt + ' Extended_Pictographic' },
          vt =
            'Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu',
          xt =
            'Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb',
          bt = {
            9: xt,
            10:
              xt +
              ' Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd',
          },
          _t = {}
        function kt(t) {
          var e = (_t[t] = {
            binary: U(gt[t] + ' ' + vt),
            nonBinary: { General_Category: U(vt), Script: U(bt[t]) },
          })
          ;(e.nonBinary.Script_Extensions = e.nonBinary.Script),
            (e.nonBinary.gc = e.nonBinary.General_Category),
            (e.nonBinary.sc = e.nonBinary.Script),
            (e.nonBinary.scx = e.nonBinary.Script_Extensions)
        }
        kt(9), kt(10)
        var St = H.prototype,
          wt = function (t) {
            ;(this.parser = t),
              (this.validFlags =
                'gim' +
                (t.options.ecmaVersion >= 6 ? 'uy' : '') +
                (t.options.ecmaVersion >= 9 ? 's' : '')),
              (this.unicodeProperties =
                _t[t.options.ecmaVersion >= 10 ? 10 : t.options.ecmaVersion]),
              (this.source = ''),
              (this.flags = ''),
              (this.start = 0),
              (this.switchU = !1),
              (this.switchN = !1),
              (this.pos = 0),
              (this.lastIntValue = 0),
              (this.lastStringValue = ''),
              (this.lastAssertionIsQuantifiable = !1),
              (this.numCapturingParens = 0),
              (this.maxBackReference = 0),
              (this.groupNames = []),
              (this.backReferenceNames = [])
          }
        function Et(t) {
          return t <= 65535
            ? String.fromCharCode(t)
            : ((t -= 65536),
              String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t)))
        }
        function Ct(t) {
          return (
            36 === t ||
            (t >= 40 && t <= 43) ||
            46 === t ||
            63 === t ||
            (t >= 91 && t <= 94) ||
            (t >= 123 && t <= 125)
          )
        }
        function At(t) {
          return (t >= 65 && t <= 90) || (t >= 97 && t <= 122)
        }
        function It(t) {
          return At(t) || 95 === t
        }
        function Lt(t) {
          return It(t) || Pt(t)
        }
        function Pt(t) {
          return t >= 48 && t <= 57
        }
        function Nt(t) {
          return (
            (t >= 48 && t <= 57) ||
            (t >= 65 && t <= 70) ||
            (t >= 97 && t <= 102)
          )
        }
        function Ot(t) {
          return t >= 65 && t <= 70
            ? t - 65 + 10
            : t >= 97 && t <= 102
            ? t - 97 + 10
            : t - 48
        }
        function jt(t) {
          return t >= 48 && t <= 55
        }
        ;(wt.prototype.reset = function (t, e, i) {
          var s = -1 !== i.indexOf('u')
          ;(this.start = 0 | t),
            (this.source = e + ''),
            (this.flags = i),
            (this.switchU = s && this.parser.options.ecmaVersion >= 6),
            (this.switchN = s && this.parser.options.ecmaVersion >= 9)
        }),
          (wt.prototype.raise = function (t) {
            this.parser.raiseRecoverable(
              this.start,
              'Invalid regular expression: /' + this.source + '/: ' + t
            )
          }),
          (wt.prototype.at = function (t) {
            var e = this.source,
              i = e.length
            if (t >= i) return -1
            var s = e.charCodeAt(t)
            return !this.switchU || s <= 55295 || s >= 57344 || t + 1 >= i
              ? s
              : (s << 10) + e.charCodeAt(t + 1) - 56613888
          }),
          (wt.prototype.nextIndex = function (t) {
            var e = this.source,
              i = e.length
            if (t >= i) return i
            var s = e.charCodeAt(t)
            return !this.switchU || s <= 55295 || s >= 57344 || t + 1 >= i
              ? t + 1
              : t + 2
          }),
          (wt.prototype.current = function () {
            return this.at(this.pos)
          }),
          (wt.prototype.lookahead = function () {
            return this.at(this.nextIndex(this.pos))
          }),
          (wt.prototype.advance = function () {
            this.pos = this.nextIndex(this.pos)
          }),
          (wt.prototype.eat = function (t) {
            return this.current() === t && (this.advance(), !0)
          }),
          (St.validateRegExpFlags = function (t) {
            for (var e = t.validFlags, i = t.flags, s = 0; s < i.length; s++) {
              var r = i.charAt(s)
              ;-1 === e.indexOf(r) &&
                this.raise(t.start, 'Invalid regular expression flag'),
                i.indexOf(r, s + 1) > -1 &&
                  this.raise(t.start, 'Duplicate regular expression flag')
            }
          }),
          (St.validateRegExpPattern = function (t) {
            this.regexp_pattern(t),
              !t.switchN &&
                this.options.ecmaVersion >= 9 &&
                t.groupNames.length > 0 &&
                ((t.switchN = !0), this.regexp_pattern(t))
          }),
          (St.regexp_pattern = function (t) {
            ;(t.pos = 0),
              (t.lastIntValue = 0),
              (t.lastStringValue = ''),
              (t.lastAssertionIsQuantifiable = !1),
              (t.numCapturingParens = 0),
              (t.maxBackReference = 0),
              (t.groupNames.length = 0),
              (t.backReferenceNames.length = 0),
              this.regexp_disjunction(t),
              t.pos !== t.source.length &&
                (t.eat(41) && t.raise("Unmatched ')'"),
                (t.eat(93) || t.eat(125)) &&
                  t.raise('Lone quantifier brackets')),
              t.maxBackReference > t.numCapturingParens &&
                t.raise('Invalid escape')
            for (var e = 0, i = t.backReferenceNames; e < i.length; e += 1)
              -1 === t.groupNames.indexOf(i[e]) &&
                t.raise('Invalid named capture referenced')
          }),
          (St.regexp_disjunction = function (t) {
            for (this.regexp_alternative(t); t.eat(124); )
              this.regexp_alternative(t)
            this.regexp_eatQuantifier(t, !0) && t.raise('Nothing to repeat'),
              t.eat(123) && t.raise('Lone quantifier brackets')
          }),
          (St.regexp_alternative = function (t) {
            for (; t.pos < t.source.length && this.regexp_eatTerm(t); );
          }),
          (St.regexp_eatTerm = function (t) {
            return this.regexp_eatAssertion(t)
              ? (t.lastAssertionIsQuantifiable &&
                  this.regexp_eatQuantifier(t) &&
                  t.switchU &&
                  t.raise('Invalid quantifier'),
                !0)
              : !(t.switchU
                  ? !this.regexp_eatAtom(t)
                  : !this.regexp_eatExtendedAtom(t)) &&
                  (this.regexp_eatQuantifier(t), !0)
          }),
          (St.regexp_eatAssertion = function (t) {
            var e = t.pos
            if (((t.lastAssertionIsQuantifiable = !1), t.eat(94) || t.eat(36)))
              return !0
            if (t.eat(92)) {
              if (t.eat(66) || t.eat(98)) return !0
              t.pos = e
            }
            if (t.eat(40) && t.eat(63)) {
              var i = !1
              if (
                (this.options.ecmaVersion >= 9 && (i = t.eat(60)),
                t.eat(61) || t.eat(33))
              )
                return (
                  this.regexp_disjunction(t),
                  t.eat(41) || t.raise('Unterminated group'),
                  (t.lastAssertionIsQuantifiable = !i),
                  !0
                )
            }
            return (t.pos = e), !1
          }),
          (St.regexp_eatQuantifier = function (t, e) {
            return (
              void 0 === e && (e = !1),
              !!this.regexp_eatQuantifierPrefix(t, e) && (t.eat(63), !0)
            )
          }),
          (St.regexp_eatQuantifierPrefix = function (t, e) {
            return (
              t.eat(42) ||
              t.eat(43) ||
              t.eat(63) ||
              this.regexp_eatBracedQuantifier(t, e)
            )
          }),
          (St.regexp_eatBracedQuantifier = function (t, e) {
            var i = t.pos
            if (t.eat(123)) {
              var s = 0,
                r = -1
              if (
                this.regexp_eatDecimalDigits(t) &&
                ((s = t.lastIntValue),
                t.eat(44) &&
                  this.regexp_eatDecimalDigits(t) &&
                  (r = t.lastIntValue),
                t.eat(125))
              )
                return (
                  -1 !== r &&
                    r < s &&
                    !e &&
                    t.raise('numbers out of order in {} quantifier'),
                  !0
                )
              t.switchU && !e && t.raise('Incomplete quantifier'), (t.pos = i)
            }
            return !1
          }),
          (St.regexp_eatAtom = function (t) {
            return (
              this.regexp_eatPatternCharacters(t) ||
              t.eat(46) ||
              this.regexp_eatReverseSolidusAtomEscape(t) ||
              this.regexp_eatCharacterClass(t) ||
              this.regexp_eatUncapturingGroup(t) ||
              this.regexp_eatCapturingGroup(t)
            )
          }),
          (St.regexp_eatReverseSolidusAtomEscape = function (t) {
            var e = t.pos
            if (t.eat(92)) {
              if (this.regexp_eatAtomEscape(t)) return !0
              t.pos = e
            }
            return !1
          }),
          (St.regexp_eatUncapturingGroup = function (t) {
            var e = t.pos
            if (t.eat(40)) {
              if (t.eat(63) && t.eat(58)) {
                if ((this.regexp_disjunction(t), t.eat(41))) return !0
                t.raise('Unterminated group')
              }
              t.pos = e
            }
            return !1
          }),
          (St.regexp_eatCapturingGroup = function (t) {
            if (t.eat(40)) {
              if (
                (this.options.ecmaVersion >= 9
                  ? this.regexp_groupSpecifier(t)
                  : 63 === t.current() && t.raise('Invalid group'),
                this.regexp_disjunction(t),
                t.eat(41))
              )
                return (t.numCapturingParens += 1), !0
              t.raise('Unterminated group')
            }
            return !1
          }),
          (St.regexp_eatExtendedAtom = function (t) {
            return (
              t.eat(46) ||
              this.regexp_eatReverseSolidusAtomEscape(t) ||
              this.regexp_eatCharacterClass(t) ||
              this.regexp_eatUncapturingGroup(t) ||
              this.regexp_eatCapturingGroup(t) ||
              this.regexp_eatInvalidBracedQuantifier(t) ||
              this.regexp_eatExtendedPatternCharacter(t)
            )
          }),
          (St.regexp_eatInvalidBracedQuantifier = function (t) {
            return (
              this.regexp_eatBracedQuantifier(t, !0) &&
                t.raise('Nothing to repeat'),
              !1
            )
          }),
          (St.regexp_eatSyntaxCharacter = function (t) {
            var e = t.current()
            return !!Ct(e) && ((t.lastIntValue = e), t.advance(), !0)
          }),
          (St.regexp_eatPatternCharacters = function (t) {
            for (var e = t.pos, i = 0; -1 !== (i = t.current()) && !Ct(i); )
              t.advance()
            return t.pos !== e
          }),
          (St.regexp_eatExtendedPatternCharacter = function (t) {
            var e = t.current()
            return !(
              -1 === e ||
              36 === e ||
              (e >= 40 && e <= 43) ||
              46 === e ||
              63 === e ||
              91 === e ||
              94 === e ||
              124 === e ||
              (t.advance(), 0)
            )
          }),
          (St.regexp_groupSpecifier = function (t) {
            if (t.eat(63)) {
              if (this.regexp_eatGroupName(t))
                return (
                  -1 !== t.groupNames.indexOf(t.lastStringValue) &&
                    t.raise('Duplicate capture group name'),
                  void t.groupNames.push(t.lastStringValue)
                )
              t.raise('Invalid group')
            }
          }),
          (St.regexp_eatGroupName = function (t) {
            if (((t.lastStringValue = ''), t.eat(60))) {
              if (this.regexp_eatRegExpIdentifierName(t) && t.eat(62)) return !0
              t.raise('Invalid capture group name')
            }
            return !1
          }),
          (St.regexp_eatRegExpIdentifierName = function (t) {
            if (
              ((t.lastStringValue = ''),
              this.regexp_eatRegExpIdentifierStart(t))
            ) {
              for (
                t.lastStringValue += Et(t.lastIntValue);
                this.regexp_eatRegExpIdentifierPart(t);

              )
                t.lastStringValue += Et(t.lastIntValue)
              return !0
            }
            return !1
          }),
          (St.regexp_eatRegExpIdentifierStart = function (t) {
            var e = t.pos,
              i = t.current()
            return (
              t.advance(),
              92 === i &&
                this.regexp_eatRegExpUnicodeEscapeSequence(t) &&
                (i = t.lastIntValue),
              (function (t) {
                return k(t, !0) || 36 === t || 95 === t
              })(i)
                ? ((t.lastIntValue = i), !0)
                : ((t.pos = e), !1)
            )
          }),
          (St.regexp_eatRegExpIdentifierPart = function (t) {
            var e = t.pos,
              i = t.current()
            return (
              t.advance(),
              92 === i &&
                this.regexp_eatRegExpUnicodeEscapeSequence(t) &&
                (i = t.lastIntValue),
              (function (t) {
                return (
                  S(t, !0) || 36 === t || 95 === t || 8204 === t || 8205 === t
                )
              })(i)
                ? ((t.lastIntValue = i), !0)
                : ((t.pos = e), !1)
            )
          }),
          (St.regexp_eatAtomEscape = function (t) {
            return (
              !!(
                this.regexp_eatBackReference(t) ||
                this.regexp_eatCharacterClassEscape(t) ||
                this.regexp_eatCharacterEscape(t) ||
                (t.switchN && this.regexp_eatKGroupName(t))
              ) ||
              (t.switchU &&
                (99 === t.current() && t.raise('Invalid unicode escape'),
                t.raise('Invalid escape')),
              !1)
            )
          }),
          (St.regexp_eatBackReference = function (t) {
            var e = t.pos
            if (this.regexp_eatDecimalEscape(t)) {
              var i = t.lastIntValue
              if (t.switchU)
                return i > t.maxBackReference && (t.maxBackReference = i), !0
              if (i <= t.numCapturingParens) return !0
              t.pos = e
            }
            return !1
          }),
          (St.regexp_eatKGroupName = function (t) {
            if (t.eat(107)) {
              if (this.regexp_eatGroupName(t))
                return t.backReferenceNames.push(t.lastStringValue), !0
              t.raise('Invalid named reference')
            }
            return !1
          }),
          (St.regexp_eatCharacterEscape = function (t) {
            return (
              this.regexp_eatControlEscape(t) ||
              this.regexp_eatCControlLetter(t) ||
              this.regexp_eatZero(t) ||
              this.regexp_eatHexEscapeSequence(t) ||
              this.regexp_eatRegExpUnicodeEscapeSequence(t) ||
              (!t.switchU && this.regexp_eatLegacyOctalEscapeSequence(t)) ||
              this.regexp_eatIdentityEscape(t)
            )
          }),
          (St.regexp_eatCControlLetter = function (t) {
            var e = t.pos
            if (t.eat(99)) {
              if (this.regexp_eatControlLetter(t)) return !0
              t.pos = e
            }
            return !1
          }),
          (St.regexp_eatZero = function (t) {
            return (
              48 === t.current() &&
              !Pt(t.lookahead()) &&
              ((t.lastIntValue = 0), t.advance(), !0)
            )
          }),
          (St.regexp_eatControlEscape = function (t) {
            var e = t.current()
            return 116 === e
              ? ((t.lastIntValue = 9), t.advance(), !0)
              : 110 === e
              ? ((t.lastIntValue = 10), t.advance(), !0)
              : 118 === e
              ? ((t.lastIntValue = 11), t.advance(), !0)
              : 102 === e
              ? ((t.lastIntValue = 12), t.advance(), !0)
              : 114 === e && ((t.lastIntValue = 13), t.advance(), !0)
          }),
          (St.regexp_eatControlLetter = function (t) {
            var e = t.current()
            return !!At(e) && ((t.lastIntValue = e % 32), t.advance(), !0)
          }),
          (St.regexp_eatRegExpUnicodeEscapeSequence = function (t) {
            var e,
              i = t.pos
            if (t.eat(117)) {
              if (this.regexp_eatFixedHexDigits(t, 4)) {
                var s = t.lastIntValue
                if (t.switchU && s >= 55296 && s <= 56319) {
                  var r = t.pos
                  if (
                    t.eat(92) &&
                    t.eat(117) &&
                    this.regexp_eatFixedHexDigits(t, 4)
                  ) {
                    var n = t.lastIntValue
                    if (n >= 56320 && n <= 57343)
                      return (
                        (t.lastIntValue =
                          1024 * (s - 55296) + (n - 56320) + 65536),
                        !0
                      )
                  }
                  ;(t.pos = r), (t.lastIntValue = s)
                }
                return !0
              }
              if (
                t.switchU &&
                t.eat(123) &&
                this.regexp_eatHexDigits(t) &&
                t.eat(125) &&
                (e = t.lastIntValue) >= 0 &&
                e <= 1114111
              )
                return !0
              t.switchU && t.raise('Invalid unicode escape'), (t.pos = i)
            }
            return !1
          }),
          (St.regexp_eatIdentityEscape = function (t) {
            if (t.switchU)
              return (
                !!this.regexp_eatSyntaxCharacter(t) ||
                (!!t.eat(47) && ((t.lastIntValue = 47), !0))
              )
            var e = t.current()
            return !(
              99 === e ||
              (t.switchN && 107 === e) ||
              ((t.lastIntValue = e), t.advance(), 0)
            )
          }),
          (St.regexp_eatDecimalEscape = function (t) {
            t.lastIntValue = 0
            var e = t.current()
            if (e >= 49 && e <= 57) {
              do {
                ;(t.lastIntValue = 10 * t.lastIntValue + (e - 48)), t.advance()
              } while ((e = t.current()) >= 48 && e <= 57)
              return !0
            }
            return !1
          }),
          (St.regexp_eatCharacterClassEscape = function (t) {
            var e = t.current()
            if (
              (function (t) {
                return (
                  100 === t ||
                  68 === t ||
                  115 === t ||
                  83 === t ||
                  119 === t ||
                  87 === t
                )
              })(e)
            )
              return (t.lastIntValue = -1), t.advance(), !0
            if (
              t.switchU &&
              this.options.ecmaVersion >= 9 &&
              (80 === e || 112 === e)
            ) {
              if (
                ((t.lastIntValue = -1),
                t.advance(),
                t.eat(123) &&
                  this.regexp_eatUnicodePropertyValueExpression(t) &&
                  t.eat(125))
              )
                return !0
              t.raise('Invalid property name')
            }
            return !1
          }),
          (St.regexp_eatUnicodePropertyValueExpression = function (t) {
            var e = t.pos
            if (this.regexp_eatUnicodePropertyName(t) && t.eat(61)) {
              var i = t.lastStringValue
              if (this.regexp_eatUnicodePropertyValue(t))
                return (
                  this.regexp_validateUnicodePropertyNameAndValue(
                    t,
                    i,
                    t.lastStringValue
                  ),
                  !0
                )
            }
            return (
              (t.pos = e),
              !!this.regexp_eatLoneUnicodePropertyNameOrValue(t) &&
                (this.regexp_validateUnicodePropertyNameOrValue(
                  t,
                  t.lastStringValue
                ),
                !0)
            )
          }),
          (St.regexp_validateUnicodePropertyNameAndValue = function (t, e, i) {
            F(t.unicodeProperties.nonBinary, e) ||
              t.raise('Invalid property name'),
              t.unicodeProperties.nonBinary[e].test(i) ||
                t.raise('Invalid property value')
          }),
          (St.regexp_validateUnicodePropertyNameOrValue = function (t, e) {
            t.unicodeProperties.binary.test(e) ||
              t.raise('Invalid property name')
          }),
          (St.regexp_eatUnicodePropertyName = function (t) {
            var e = 0
            for (t.lastStringValue = ''; It((e = t.current())); )
              (t.lastStringValue += Et(e)), t.advance()
            return '' !== t.lastStringValue
          }),
          (St.regexp_eatUnicodePropertyValue = function (t) {
            var e = 0
            for (t.lastStringValue = ''; Lt((e = t.current())); )
              (t.lastStringValue += Et(e)), t.advance()
            return '' !== t.lastStringValue
          }),
          (St.regexp_eatLoneUnicodePropertyNameOrValue = function (t) {
            return this.regexp_eatUnicodePropertyValue(t)
          }),
          (St.regexp_eatCharacterClass = function (t) {
            if (t.eat(91)) {
              if ((t.eat(94), this.regexp_classRanges(t), t.eat(93))) return !0
              t.raise('Unterminated character class')
            }
            return !1
          }),
          (St.regexp_classRanges = function (t) {
            for (; this.regexp_eatClassAtom(t); ) {
              var e = t.lastIntValue
              if (t.eat(45) && this.regexp_eatClassAtom(t)) {
                var i = t.lastIntValue
                !t.switchU ||
                  (-1 !== e && -1 !== i) ||
                  t.raise('Invalid character class'),
                  -1 !== e &&
                    -1 !== i &&
                    e > i &&
                    t.raise('Range out of order in character class')
              }
            }
          }),
          (St.regexp_eatClassAtom = function (t) {
            var e = t.pos
            if (t.eat(92)) {
              if (this.regexp_eatClassEscape(t)) return !0
              if (t.switchU) {
                var i = t.current()
                ;(99 === i || jt(i)) && t.raise('Invalid class escape'),
                  t.raise('Invalid escape')
              }
              t.pos = e
            }
            var s = t.current()
            return 93 !== s && ((t.lastIntValue = s), t.advance(), !0)
          }),
          (St.regexp_eatClassEscape = function (t) {
            var e = t.pos
            if (t.eat(98)) return (t.lastIntValue = 8), !0
            if (t.switchU && t.eat(45)) return (t.lastIntValue = 45), !0
            if (!t.switchU && t.eat(99)) {
              if (this.regexp_eatClassControlLetter(t)) return !0
              t.pos = e
            }
            return (
              this.regexp_eatCharacterClassEscape(t) ||
              this.regexp_eatCharacterEscape(t)
            )
          }),
          (St.regexp_eatClassControlLetter = function (t) {
            var e = t.current()
            return !(
              (!Pt(e) && 95 !== e) ||
              ((t.lastIntValue = e % 32), t.advance(), 0)
            )
          }),
          (St.regexp_eatHexEscapeSequence = function (t) {
            var e = t.pos
            if (t.eat(120)) {
              if (this.regexp_eatFixedHexDigits(t, 2)) return !0
              t.switchU && t.raise('Invalid escape'), (t.pos = e)
            }
            return !1
          }),
          (St.regexp_eatDecimalDigits = function (t) {
            var e = t.pos,
              i = 0
            for (t.lastIntValue = 0; Pt((i = t.current())); )
              (t.lastIntValue = 10 * t.lastIntValue + (i - 48)), t.advance()
            return t.pos !== e
          }),
          (St.regexp_eatHexDigits = function (t) {
            var e = t.pos,
              i = 0
            for (t.lastIntValue = 0; Nt((i = t.current())); )
              (t.lastIntValue = 16 * t.lastIntValue + Ot(i)), t.advance()
            return t.pos !== e
          }),
          (St.regexp_eatLegacyOctalEscapeSequence = function (t) {
            if (this.regexp_eatOctalDigit(t)) {
              var e = t.lastIntValue
              if (this.regexp_eatOctalDigit(t)) {
                var i = t.lastIntValue
                t.lastIntValue =
                  e <= 3 && this.regexp_eatOctalDigit(t)
                    ? 64 * e + 8 * i + t.lastIntValue
                    : 8 * e + i
              } else t.lastIntValue = e
              return !0
            }
            return !1
          }),
          (St.regexp_eatOctalDigit = function (t) {
            var e = t.current()
            return jt(e)
              ? ((t.lastIntValue = e - 48), t.advance(), !0)
              : ((t.lastIntValue = 0), !1)
          }),
          (St.regexp_eatFixedHexDigits = function (t, e) {
            var i = t.pos
            t.lastIntValue = 0
            for (var s = 0; s < e; ++s) {
              var r = t.current()
              if (!Nt(r)) return (t.pos = i), !1
              ;(t.lastIntValue = 16 * t.lastIntValue + Ot(r)), t.advance()
            }
            return !0
          })
        var Tt = function (t) {
            ;(this.type = t.type),
              (this.value = t.value),
              (this.start = t.start),
              (this.end = t.end),
              t.options.locations &&
                (this.loc = new J(t, t.startLoc, t.endLoc)),
              t.options.ranges && (this.range = [t.start, t.end])
          },
          Rt = H.prototype
        function Vt(t) {
          return t <= 65535
            ? String.fromCharCode(t)
            : ((t -= 65536),
              String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t)))
        }
        ;(Rt.next = function () {
          this.options.onToken && this.options.onToken(new Tt(this)),
            (this.lastTokEnd = this.end),
            (this.lastTokStart = this.start),
            (this.lastTokEndLoc = this.endLoc),
            (this.lastTokStartLoc = this.startLoc),
            this.nextToken()
        }),
          (Rt.getToken = function () {
            return this.next(), new Tt(this)
          }),
          'undefined' != typeof Symbol &&
            (Rt[Symbol.iterator] = function () {
              var t = this
              return {
                next: function () {
                  var e = t.getToken()
                  return { done: e.type === P.eof, value: e }
                },
              }
            }),
          (Rt.curContext = function () {
            return this.context[this.context.length - 1]
          }),
          (Rt.nextToken = function () {
            var t = this.curContext()
            return (
              (t && t.preserveSpace) || this.skipSpace(),
              (this.start = this.pos),
              this.options.locations && (this.startLoc = this.curPosition()),
              this.pos >= this.input.length
                ? this.finishToken(P.eof)
                : t.override
                ? t.override(this)
                : void this.readToken(this.fullCharCodeAtPos())
            )
          }),
          (Rt.readToken = function (t) {
            return k(t, this.options.ecmaVersion >= 6) || 92 === t
              ? this.readWord()
              : this.getTokenFromCode(t)
          }),
          (Rt.fullCharCodeAtPos = function () {
            var t = this.input.charCodeAt(this.pos)
            return t <= 55295 || t >= 57344
              ? t
              : (t << 10) + this.input.charCodeAt(this.pos + 1) - 56613888
          }),
          (Rt.skipBlockComment = function () {
            var t,
              e = this.options.onComment && this.curPosition(),
              i = this.pos,
              s = this.input.indexOf('*/', (this.pos += 2))
            if (
              (-1 === s && this.raise(this.pos - 2, 'Unterminated comment'),
              (this.pos = s + 2),
              this.options.locations)
            )
              for (
                O.lastIndex = i;
                (t = O.exec(this.input)) && t.index < this.pos;

              )
                ++this.curLine, (this.lineStart = t.index + t[0].length)
            this.options.onComment &&
              this.options.onComment(
                !0,
                this.input.slice(i + 2, s),
                i,
                this.pos,
                e,
                this.curPosition()
              )
          }),
          (Rt.skipLineComment = function (t) {
            for (
              var e = this.pos,
                i = this.options.onComment && this.curPosition(),
                s = this.input.charCodeAt((this.pos += t));
              this.pos < this.input.length && !j(s);

            )
              s = this.input.charCodeAt(++this.pos)
            this.options.onComment &&
              this.options.onComment(
                !1,
                this.input.slice(e + t, this.pos),
                e,
                this.pos,
                i,
                this.curPosition()
              )
          }),
          (Rt.skipSpace = function () {
            t: for (; this.pos < this.input.length; ) {
              var t = this.input.charCodeAt(this.pos)
              switch (t) {
                case 32:
                case 160:
                  ++this.pos
                  break
                case 13:
                  10 === this.input.charCodeAt(this.pos + 1) && ++this.pos
                case 10:
                case 8232:
                case 8233:
                  ++this.pos,
                    this.options.locations &&
                      (++this.curLine, (this.lineStart = this.pos))
                  break
                case 47:
                  switch (this.input.charCodeAt(this.pos + 1)) {
                    case 42:
                      this.skipBlockComment()
                      break
                    case 47:
                      this.skipLineComment(2)
                      break
                    default:
                      break t
                  }
                  break
                default:
                  if (
                    !(
                      (t > 8 && t < 14) ||
                      (t >= 5760 && T.test(String.fromCharCode(t)))
                    )
                  )
                    break t
                  ++this.pos
              }
            }
          }),
          (Rt.finishToken = function (t, e) {
            ;(this.end = this.pos),
              this.options.locations && (this.endLoc = this.curPosition())
            var i = this.type
            ;(this.type = t), (this.value = e), this.updateContext(i)
          }),
          (Rt.readToken_dot = function () {
            var t = this.input.charCodeAt(this.pos + 1)
            if (t >= 48 && t <= 57) return this.readNumber(!0)
            var e = this.input.charCodeAt(this.pos + 2)
            return this.options.ecmaVersion >= 6 && 46 === t && 46 === e
              ? ((this.pos += 3), this.finishToken(P.ellipsis))
              : (++this.pos, this.finishToken(P.dot))
          }),
          (Rt.readToken_slash = function () {
            var t = this.input.charCodeAt(this.pos + 1)
            return this.exprAllowed
              ? (++this.pos, this.readRegexp())
              : 61 === t
              ? this.finishOp(P.assign, 2)
              : this.finishOp(P.slash, 1)
          }),
          (Rt.readToken_mult_modulo_exp = function (t) {
            var e = this.input.charCodeAt(this.pos + 1),
              i = 1,
              s = 42 === t ? P.star : P.modulo
            return (
              this.options.ecmaVersion >= 7 &&
                42 === t &&
                42 === e &&
                (++i,
                (s = P.starstar),
                (e = this.input.charCodeAt(this.pos + 2))),
              61 === e ? this.finishOp(P.assign, i + 1) : this.finishOp(s, i)
            )
          }),
          (Rt.readToken_pipe_amp = function (t) {
            var e = this.input.charCodeAt(this.pos + 1)
            return e === t
              ? this.finishOp(124 === t ? P.logicalOR : P.logicalAND, 2)
              : 61 === e
              ? this.finishOp(P.assign, 2)
              : this.finishOp(124 === t ? P.bitwiseOR : P.bitwiseAND, 1)
          }),
          (Rt.readToken_caret = function () {
            return 61 === this.input.charCodeAt(this.pos + 1)
              ? this.finishOp(P.assign, 2)
              : this.finishOp(P.bitwiseXOR, 1)
          }),
          (Rt.readToken_plus_min = function (t) {
            var e = this.input.charCodeAt(this.pos + 1)
            return e === t
              ? 45 !== e ||
                this.inModule ||
                62 !== this.input.charCodeAt(this.pos + 2) ||
                (0 !== this.lastTokEnd &&
                  !N.test(this.input.slice(this.lastTokEnd, this.pos)))
                ? this.finishOp(P.incDec, 2)
                : (this.skipLineComment(3), this.skipSpace(), this.nextToken())
              : 61 === e
              ? this.finishOp(P.assign, 2)
              : this.finishOp(P.plusMin, 1)
          }),
          (Rt.readToken_lt_gt = function (t) {
            var e = this.input.charCodeAt(this.pos + 1),
              i = 1
            return e === t
              ? ((i =
                  62 === t && 62 === this.input.charCodeAt(this.pos + 2)
                    ? 3
                    : 2),
                61 === this.input.charCodeAt(this.pos + i)
                  ? this.finishOp(P.assign, i + 1)
                  : this.finishOp(P.bitShift, i))
              : 33 !== e ||
                60 !== t ||
                this.inModule ||
                45 !== this.input.charCodeAt(this.pos + 2) ||
                45 !== this.input.charCodeAt(this.pos + 3)
              ? (61 === e && (i = 2), this.finishOp(P.relational, i))
              : (this.skipLineComment(4), this.skipSpace(), this.nextToken())
          }),
          (Rt.readToken_eq_excl = function (t) {
            var e = this.input.charCodeAt(this.pos + 1)
            return 61 === e
              ? this.finishOp(
                  P.equality,
                  61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2
                )
              : 61 === t && 62 === e && this.options.ecmaVersion >= 6
              ? ((this.pos += 2), this.finishToken(P.arrow))
              : this.finishOp(61 === t ? P.eq : P.prefix, 1)
          }),
          (Rt.getTokenFromCode = function (t) {
            switch (t) {
              case 46:
                return this.readToken_dot()
              case 40:
                return ++this.pos, this.finishToken(P.parenL)
              case 41:
                return ++this.pos, this.finishToken(P.parenR)
              case 59:
                return ++this.pos, this.finishToken(P.semi)
              case 44:
                return ++this.pos, this.finishToken(P.comma)
              case 91:
                return ++this.pos, this.finishToken(P.bracketL)
              case 93:
                return ++this.pos, this.finishToken(P.bracketR)
              case 123:
                return ++this.pos, this.finishToken(P.braceL)
              case 125:
                return ++this.pos, this.finishToken(P.braceR)
              case 58:
                return ++this.pos, this.finishToken(P.colon)
              case 63:
                return ++this.pos, this.finishToken(P.question)
              case 96:
                if (this.options.ecmaVersion < 6) break
                return ++this.pos, this.finishToken(P.backQuote)
              case 48:
                var e = this.input.charCodeAt(this.pos + 1)
                if (120 === e || 88 === e) return this.readRadixNumber(16)
                if (this.options.ecmaVersion >= 6) {
                  if (111 === e || 79 === e) return this.readRadixNumber(8)
                  if (98 === e || 66 === e) return this.readRadixNumber(2)
                }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return this.readNumber(!1)
              case 34:
              case 39:
                return this.readString(t)
              case 47:
                return this.readToken_slash()
              case 37:
              case 42:
                return this.readToken_mult_modulo_exp(t)
              case 124:
              case 38:
                return this.readToken_pipe_amp(t)
              case 94:
                return this.readToken_caret()
              case 43:
              case 45:
                return this.readToken_plus_min(t)
              case 60:
              case 62:
                return this.readToken_lt_gt(t)
              case 61:
              case 33:
                return this.readToken_eq_excl(t)
              case 126:
                return this.finishOp(P.prefix, 1)
            }
            this.raise(this.pos, "Unexpected character '" + Vt(t) + "'")
          }),
          (Rt.finishOp = function (t, e) {
            var i = this.input.slice(this.pos, this.pos + e)
            return (this.pos += e), this.finishToken(t, i)
          }),
          (Rt.readRegexp = function () {
            for (var t, e, i = this.pos; ; ) {
              this.pos >= this.input.length &&
                this.raise(i, 'Unterminated regular expression')
              var s = this.input.charAt(this.pos)
              if (
                (N.test(s) && this.raise(i, 'Unterminated regular expression'),
                t)
              )
                t = !1
              else {
                if ('[' === s) e = !0
                else if (']' === s && e) e = !1
                else if ('/' === s && !e) break
                t = '\\' === s
              }
              ++this.pos
            }
            var r = this.input.slice(i, this.pos)
            ++this.pos
            var n = this.pos,
              a = this.readWord1()
            this.containsEsc && this.unexpected(n)
            var o = this.regexpState || (this.regexpState = new wt(this))
            o.reset(i, r, a),
              this.validateRegExpFlags(o),
              this.validateRegExpPattern(o)
            var p = null
            try {
              p = new RegExp(r, a)
            } catch (t) {}
            return this.finishToken(P.regexp, {
              pattern: r,
              flags: a,
              value: p,
            })
          }),
          (Rt.readInt = function (t, e) {
            for (
              var i = this.pos, s = 0, r = 0, n = null == e ? 1 / 0 : e;
              r < n;
              ++r
            ) {
              var a,
                o = this.input.charCodeAt(this.pos)
              if (
                (a =
                  o >= 97
                    ? o - 97 + 10
                    : o >= 65
                    ? o - 65 + 10
                    : o >= 48 && o <= 57
                    ? o - 48
                    : 1 / 0) >= t
              )
                break
              ++this.pos, (s = s * t + a)
            }
            return this.pos === i || (null != e && this.pos - i !== e)
              ? null
              : s
          }),
          (Rt.readRadixNumber = function (t) {
            this.pos += 2
            var e = this.readInt(t)
            return (
              null == e &&
                this.raise(this.start + 2, 'Expected number in radix ' + t),
              k(this.fullCharCodeAtPos()) &&
                this.raise(this.pos, 'Identifier directly after number'),
              this.finishToken(P.num, e)
            )
          }),
          (Rt.readNumber = function (t) {
            var e = this.pos
            t || null !== this.readInt(10) || this.raise(e, 'Invalid number')
            var i = this.pos - e >= 2 && 48 === this.input.charCodeAt(e)
            i && this.strict && this.raise(e, 'Invalid number'),
              i && /[89]/.test(this.input.slice(e, this.pos)) && (i = !1)
            var s = this.input.charCodeAt(this.pos)
            46 !== s ||
              i ||
              (++this.pos,
              this.readInt(10),
              (s = this.input.charCodeAt(this.pos))),
              (69 !== s && 101 !== s) ||
                i ||
                ((43 !== (s = this.input.charCodeAt(++this.pos)) && 45 !== s) ||
                  ++this.pos,
                null === this.readInt(10) && this.raise(e, 'Invalid number')),
              k(this.fullCharCodeAtPos()) &&
                this.raise(this.pos, 'Identifier directly after number')
            var r = this.input.slice(e, this.pos),
              n = i ? parseInt(r, 8) : parseFloat(r)
            return this.finishToken(P.num, n)
          }),
          (Rt.readCodePoint = function () {
            var t
            if (123 === this.input.charCodeAt(this.pos)) {
              this.options.ecmaVersion < 6 && this.unexpected()
              var e = ++this.pos
              ;(t = this.readHexChar(
                this.input.indexOf('}', this.pos) - this.pos
              )),
                ++this.pos,
                t > 1114111 &&
                  this.invalidStringToken(e, 'Code point out of bounds')
            } else t = this.readHexChar(4)
            return t
          }),
          (Rt.readString = function (t) {
            for (var e = '', i = ++this.pos; ; ) {
              this.pos >= this.input.length &&
                this.raise(this.start, 'Unterminated string constant')
              var s = this.input.charCodeAt(this.pos)
              if (s === t) break
              92 === s
                ? ((e += this.input.slice(i, this.pos)),
                  (e += this.readEscapedChar(!1)),
                  (i = this.pos))
                : (j(s, this.options.ecmaVersion >= 10) &&
                    this.raise(this.start, 'Unterminated string constant'),
                  ++this.pos)
            }
            return (
              (e += this.input.slice(i, this.pos++)),
              this.finishToken(P.string, e)
            )
          })
        var Dt = {}
        ;(Rt.tryReadTemplateToken = function () {
          this.inTemplateElement = !0
          try {
            this.readTmplToken()
          } catch (l) {
            if (l !== Dt) throw l
            this.readInvalidTemplateToken()
          }
          this.inTemplateElement = !1
        }),
          (Rt.invalidStringToken = function (t, e) {
            if (this.inTemplateElement && this.options.ecmaVersion >= 9)
              throw Dt
            this.raise(t, e)
          }),
          (Rt.readTmplToken = function () {
            for (var t = '', e = this.pos; ; ) {
              this.pos >= this.input.length &&
                this.raise(this.start, 'Unterminated template')
              var i = this.input.charCodeAt(this.pos)
              if (
                96 === i ||
                (36 === i && 123 === this.input.charCodeAt(this.pos + 1))
              )
                return this.pos !== this.start ||
                  (this.type !== P.template && this.type !== P.invalidTemplate)
                  ? ((t += this.input.slice(e, this.pos)),
                    this.finishToken(P.template, t))
                  : 36 === i
                  ? ((this.pos += 2), this.finishToken(P.dollarBraceL))
                  : (++this.pos, this.finishToken(P.backQuote))
              if (92 === i)
                (t += this.input.slice(e, this.pos)),
                  (t += this.readEscapedChar(!0)),
                  (e = this.pos)
              else if (j(i)) {
                switch (((t += this.input.slice(e, this.pos)), ++this.pos, i)) {
                  case 13:
                    10 === this.input.charCodeAt(this.pos) && ++this.pos
                  case 10:
                    t += '\n'
                    break
                  default:
                    t += String.fromCharCode(i)
                }
                this.options.locations &&
                  (++this.curLine, (this.lineStart = this.pos)),
                  (e = this.pos)
              } else ++this.pos
            }
          }),
          (Rt.readInvalidTemplateToken = function () {
            for (; this.pos < this.input.length; this.pos++)
              switch (this.input[this.pos]) {
                case '\\':
                  ++this.pos
                  break
                case '$':
                  if ('{' !== this.input[this.pos + 1]) break
                case '`':
                  return this.finishToken(
                    P.invalidTemplate,
                    this.input.slice(this.start, this.pos)
                  )
              }
            this.raise(this.start, 'Unterminated template')
          }),
          (Rt.readEscapedChar = function (t) {
            var e = this.input.charCodeAt(++this.pos)
            switch ((++this.pos, e)) {
              case 110:
                return '\n'
              case 114:
                return '\r'
              case 120:
                return String.fromCharCode(this.readHexChar(2))
              case 117:
                return Vt(this.readCodePoint())
              case 116:
                return '\t'
              case 98:
                return '\b'
              case 118:
                return '\v'
              case 102:
                return '\f'
              case 13:
                10 === this.input.charCodeAt(this.pos) && ++this.pos
              case 10:
                return (
                  this.options.locations &&
                    ((this.lineStart = this.pos), ++this.curLine),
                  ''
                )
              default:
                if (e >= 48 && e <= 55) {
                  var i = this.input
                      .substr(this.pos - 1, 3)
                      .match(/^[0-7]+/)[0],
                    s = parseInt(i, 8)
                  return (
                    s > 255 && ((i = i.slice(0, -1)), (s = parseInt(i, 8))),
                    (this.pos += i.length - 1),
                    (e = this.input.charCodeAt(this.pos)),
                    ('0' === i && 56 !== e && 57 !== e) ||
                      (!this.strict && !t) ||
                      this.invalidStringToken(
                        this.pos - 1 - i.length,
                        t
                          ? 'Octal literal in template string'
                          : 'Octal literal in strict mode'
                      ),
                    String.fromCharCode(s)
                  )
                }
                return j(e) ? '' : String.fromCharCode(e)
            }
          }),
          (Rt.readHexChar = function (t) {
            var e = this.pos,
              i = this.readInt(16, t)
            return (
              null === i &&
                this.invalidStringToken(e, 'Bad character escape sequence'),
              i
            )
          }),
          (Rt.readWord1 = function () {
            this.containsEsc = !1
            for (
              var t = '',
                e = !0,
                i = this.pos,
                s = this.options.ecmaVersion >= 6;
              this.pos < this.input.length;

            ) {
              var r = this.fullCharCodeAtPos()
              if (S(r, s)) this.pos += r <= 65535 ? 1 : 2
              else {
                if (92 !== r) break
                ;(this.containsEsc = !0), (t += this.input.slice(i, this.pos))
                var n = this.pos
                117 !== this.input.charCodeAt(++this.pos) &&
                  this.invalidStringToken(
                    this.pos,
                    'Expecting Unicode escape sequence \\uXXXX'
                  ),
                  ++this.pos
                var a = this.readCodePoint()
                ;(e ? k : S)(a, s) ||
                  this.invalidStringToken(n, 'Invalid Unicode escape'),
                  (t += Vt(a)),
                  (i = this.pos)
              }
              e = !1
            }
            return t + this.input.slice(i, this.pos)
          }),
          (Rt.readWord = function () {
            var t = this.readWord1(),
              e = P.name
            return (
              this.keywords.test(t) &&
                (this.containsEsc &&
                  this.raiseRecoverable(
                    this.start,
                    'Escape sequence in keyword ' + t
                  ),
                (e = I[t])),
              this.finishToken(e, t)
            )
          })
        var Bt = {
            quot: '"',
            amp: '&',
            apos: "'",
            lt: '<',
            gt: '>',
            nbsp: ' ',
            iexcl: '¡',
            cent: '¢',
            pound: '£',
            curren: '¤',
            yen: '¥',
            brvbar: '¦',
            sect: '§',
            uml: '¨',
            copy: '©',
            ordf: 'ª',
            laquo: '«',
            not: '¬',
            shy: '­',
            reg: '®',
            macr: '¯',
            deg: '°',
            plusmn: '±',
            sup2: '²',
            sup3: '³',
            acute: '´',
            micro: 'µ',
            para: '¶',
            middot: '·',
            cedil: '¸',
            sup1: '¹',
            ordm: 'º',
            raquo: '»',
            frac14: '¼',
            frac12: '½',
            frac34: '¾',
            iquest: '¿',
            Agrave: 'À',
            Aacute: 'Á',
            Acirc: 'Â',
            Atilde: 'Ã',
            Auml: 'Ä',
            Aring: 'Å',
            AElig: 'Æ',
            Ccedil: 'Ç',
            Egrave: 'È',
            Eacute: 'É',
            Ecirc: 'Ê',
            Euml: 'Ë',
            Igrave: 'Ì',
            Iacute: 'Í',
            Icirc: 'Î',
            Iuml: 'Ï',
            ETH: 'Ð',
            Ntilde: 'Ñ',
            Ograve: 'Ò',
            Oacute: 'Ó',
            Ocirc: 'Ô',
            Otilde: 'Õ',
            Ouml: 'Ö',
            times: '×',
            Oslash: 'Ø',
            Ugrave: 'Ù',
            Uacute: 'Ú',
            Ucirc: 'Û',
            Uuml: 'Ü',
            Yacute: 'Ý',
            THORN: 'Þ',
            szlig: 'ß',
            agrave: 'à',
            aacute: 'á',
            acirc: 'â',
            atilde: 'ã',
            auml: 'ä',
            aring: 'å',
            aelig: 'æ',
            ccedil: 'ç',
            egrave: 'è',
            eacute: 'é',
            ecirc: 'ê',
            euml: 'ë',
            igrave: 'ì',
            iacute: 'í',
            icirc: 'î',
            iuml: 'ï',
            eth: 'ð',
            ntilde: 'ñ',
            ograve: 'ò',
            oacute: 'ó',
            ocirc: 'ô',
            otilde: 'õ',
            ouml: 'ö',
            divide: '÷',
            oslash: 'ø',
            ugrave: 'ù',
            uacute: 'ú',
            ucirc: 'û',
            uuml: 'ü',
            yacute: 'ý',
            thorn: 'þ',
            yuml: 'ÿ',
            OElig: 'Œ',
            oelig: 'œ',
            Scaron: 'Š',
            scaron: 'š',
            Yuml: 'Ÿ',
            fnof: 'ƒ',
            circ: 'ˆ',
            tilde: '˜',
            Alpha: 'Α',
            Beta: 'Β',
            Gamma: 'Γ',
            Delta: 'Δ',
            Epsilon: 'Ε',
            Zeta: 'Ζ',
            Eta: 'Η',
            Theta: 'Θ',
            Iota: 'Ι',
            Kappa: 'Κ',
            Lambda: 'Λ',
            Mu: 'Μ',
            Nu: 'Ν',
            Xi: 'Ξ',
            Omicron: 'Ο',
            Pi: 'Π',
            Rho: 'Ρ',
            Sigma: 'Σ',
            Tau: 'Τ',
            Upsilon: 'Υ',
            Phi: 'Φ',
            Chi: 'Χ',
            Psi: 'Ψ',
            Omega: 'Ω',
            alpha: 'α',
            beta: 'β',
            gamma: 'γ',
            delta: 'δ',
            epsilon: 'ε',
            zeta: 'ζ',
            eta: 'η',
            theta: 'θ',
            iota: 'ι',
            kappa: 'κ',
            lambda: 'λ',
            mu: 'μ',
            nu: 'ν',
            xi: 'ξ',
            omicron: 'ο',
            pi: 'π',
            rho: 'ρ',
            sigmaf: 'ς',
            sigma: 'σ',
            tau: 'τ',
            upsilon: 'υ',
            phi: 'φ',
            chi: 'χ',
            psi: 'ψ',
            omega: 'ω',
            thetasym: 'ϑ',
            upsih: 'ϒ',
            piv: 'ϖ',
            ensp: ' ',
            emsp: ' ',
            thinsp: ' ',
            zwnj: '‌',
            zwj: '‍',
            lrm: '‎',
            rlm: '‏',
            ndash: '–',
            mdash: '—',
            lsquo: '‘',
            rsquo: '’',
            sbquo: '‚',
            ldquo: '“',
            rdquo: '”',
            bdquo: '„',
            dagger: '†',
            Dagger: '‡',
            bull: '•',
            hellip: '…',
            permil: '‰',
            prime: '′',
            Prime: '″',
            lsaquo: '‹',
            rsaquo: '›',
            oline: '‾',
            frasl: '⁄',
            euro: '€',
            image: 'ℑ',
            weierp: '℘',
            real: 'ℜ',
            trade: '™',
            alefsym: 'ℵ',
            larr: '←',
            uarr: '↑',
            rarr: '→',
            darr: '↓',
            harr: '↔',
            crarr: '↵',
            lArr: '⇐',
            uArr: '⇑',
            rArr: '⇒',
            dArr: '⇓',
            hArr: '⇔',
            forall: '∀',
            part: '∂',
            exist: '∃',
            empty: '∅',
            nabla: '∇',
            isin: '∈',
            notin: '∉',
            ni: '∋',
            prod: '∏',
            sum: '∑',
            minus: '−',
            lowast: '∗',
            radic: '√',
            prop: '∝',
            infin: '∞',
            ang: '∠',
            and: '∧',
            or: '∨',
            cap: '∩',
            cup: '∪',
            int: '∫',
            there4: '∴',
            sim: '∼',
            cong: '≅',
            asymp: '≈',
            ne: '≠',
            equiv: '≡',
            le: '≤',
            ge: '≥',
            sub: '⊂',
            sup: '⊃',
            nsub: '⊄',
            sube: '⊆',
            supe: '⊇',
            oplus: '⊕',
            otimes: '⊗',
            perp: '⊥',
            sdot: '⋅',
            lceil: '⌈',
            rceil: '⌉',
            lfloor: '⌊',
            rfloor: '⌋',
            lang: '〈',
            rang: '〉',
            loz: '◊',
            spades: '♠',
            clubs: '♣',
            hearts: '♥',
            diams: '♦',
          },
          Ft = {
            version: '6.1.1',
            parse: function (t, e) {
              return H.parse(t, e)
            },
            parseExpressionAt: function (t, e, i) {
              return H.parseExpressionAt(t, e, i)
            },
            tokenizer: function (t, e) {
              return H.tokenizer(t, e)
            },
            Parser: H,
            defaultOptions: z,
            Position: q,
            SourceLocation: J,
            getLineInfo: X,
            Node: ct,
            TokenType: w,
            tokTypes: P,
            keywordTypes: I,
            TokContext: dt,
            tokContexts: ft,
            isIdentifierChar: S,
            isIdentifierStart: k,
            Token: Tt,
            isNewLine: j,
            lineBreak: N,
            lineBreakG: O,
            nonASCIIwhitespace: T,
          },
          Mt = /^[\da-fA-F]+$/,
          Ut = /^\d+$/,
          qt = Ft.tokTypes,
          Jt = Ft.TokContext,
          Xt = Ft.tokContexts,
          zt = Ft.TokenType,
          Wt = Ft.isNewLine,
          Ht = Ft.isIdentifierStart,
          Gt = Ft.isIdentifierChar,
          Qt = new Jt('<tag', !1),
          Kt = new Jt('</tag', !1),
          $t = new Jt('<tag>...</tag>', !0, !0),
          Zt = {
            jsxName: new zt('jsxName'),
            jsxText: new zt('jsxText', { beforeExpr: !0 }),
            jsxTagStart: new zt('jsxTagStart'),
            jsxTagEnd: new zt('jsxTagEnd'),
          }
        function Yt(t) {
          return t
            ? 'JSXIdentifier' === t.type
              ? t.name
              : 'JSXNamespacedName' === t.type
              ? t.namespace.name + ':' + t.name.name
              : 'JSXMemberExpression' === t.type
              ? Yt(t.object) + '.' + Yt(t.property)
              : void 0
            : t
        }
        ;(Zt.jsxTagStart.updateContext = function () {
          this.context.push($t), this.context.push(Qt), (this.exprAllowed = !1)
        }),
          (Zt.jsxTagEnd.updateContext = function (t) {
            var e = this.context.pop()
            ;(e === Qt && t === qt.slash) || e === Kt
              ? (this.context.pop(),
                (this.exprAllowed = this.curContext() === $t))
              : (this.exprAllowed = !0)
          })
        var te = function (t) {
          return (
            (t = t || {}),
            function (e) {
              return (function (t, e) {
                return (function (e) {
                  Object(a.a)(o, e)
                  var i = h(o)
                  function o() {
                    return Object(s.a)(this, o), i.apply(this, arguments)
                  }
                  return (
                    Object(r.a)(o, [
                      {
                        key: 'jsx_readToken',
                        value: function () {
                          for (var t = '', e = this.pos; ; ) {
                            this.pos >= this.input.length &&
                              this.raise(
                                this.start,
                                'Unterminated JSX contents'
                              )
                            var i = this.input.charCodeAt(this.pos)
                            switch (i) {
                              case 60:
                              case 123:
                                return this.pos === this.start
                                  ? 60 === i && this.exprAllowed
                                    ? (++this.pos,
                                      this.finishToken(Zt.jsxTagStart))
                                    : this.getTokenFromCode(i)
                                  : ((t += this.input.slice(e, this.pos)),
                                    this.finishToken(Zt.jsxText, t))
                              case 38:
                                ;(t += this.input.slice(e, this.pos)),
                                  (t += this.jsx_readEntity()),
                                  (e = this.pos)
                                break
                              default:
                                Wt(i)
                                  ? ((t += this.input.slice(e, this.pos)),
                                    (t += this.jsx_readNewLine(!0)),
                                    (e = this.pos))
                                  : ++this.pos
                            }
                          }
                        },
                      },
                      {
                        key: 'jsx_readNewLine',
                        value: function (t) {
                          var e,
                            i = this.input.charCodeAt(this.pos)
                          return (
                            ++this.pos,
                            13 === i && 10 === this.input.charCodeAt(this.pos)
                              ? (++this.pos, (e = t ? '\n' : '\r\n'))
                              : (e = String.fromCharCode(i)),
                            this.options.locations &&
                              (++this.curLine, (this.lineStart = this.pos)),
                            e
                          )
                        },
                      },
                      {
                        key: 'jsx_readString',
                        value: function (t) {
                          for (var e = '', i = ++this.pos; ; ) {
                            this.pos >= this.input.length &&
                              this.raise(
                                this.start,
                                'Unterminated string constant'
                              )
                            var s = this.input.charCodeAt(this.pos)
                            if (s === t) break
                            38 === s
                              ? ((e += this.input.slice(i, this.pos)),
                                (e += this.jsx_readEntity()),
                                (i = this.pos))
                              : Wt(s)
                              ? ((e += this.input.slice(i, this.pos)),
                                (e += this.jsx_readNewLine(!1)),
                                (i = this.pos))
                              : ++this.pos
                          }
                          return (
                            (e += this.input.slice(i, this.pos++)),
                            this.finishToken(qt.string, e)
                          )
                        },
                      },
                      {
                        key: 'jsx_readEntity',
                        value: function () {
                          var t,
                            e = '',
                            i = 0,
                            s = this.input[this.pos]
                          '&' !== s &&
                            this.raise(
                              this.pos,
                              'Entity must start with an ampersand'
                            )
                          for (
                            var r = ++this.pos;
                            this.pos < this.input.length && i++ < 10;

                          ) {
                            if (';' === (s = this.input[this.pos++])) {
                              '#' === e[0]
                                ? 'x' === e[1]
                                  ? ((e = e.substr(2)),
                                    Mt.test(e) &&
                                      (t = String.fromCharCode(
                                        parseInt(e, 16)
                                      )))
                                  : ((e = e.substr(1)),
                                    Ut.test(e) &&
                                      (t = String.fromCharCode(
                                        parseInt(e, 10)
                                      )))
                                : (t = Bt[e])
                              break
                            }
                            e += s
                          }
                          return t || ((this.pos = r), '&')
                        },
                      },
                      {
                        key: 'jsx_readWord',
                        value: function () {
                          var t,
                            e = this.pos
                          do {
                            t = this.input.charCodeAt(++this.pos)
                          } while (Gt(t) || 45 === t)
                          return this.finishToken(
                            Zt.jsxName,
                            this.input.slice(e, this.pos)
                          )
                        },
                      },
                      {
                        key: 'jsx_parseIdentifier',
                        value: function () {
                          var t = this.startNode()
                          return (
                            this.type === Zt.jsxName
                              ? (t.name = this.value)
                              : this.type.keyword
                              ? (t.name = this.type.keyword)
                              : this.unexpected(),
                            this.next(),
                            this.finishNode(t, 'JSXIdentifier')
                          )
                        },
                      },
                      {
                        key: 'jsx_parseNamespacedName',
                        value: function () {
                          var e = this.start,
                            i = this.startLoc,
                            s = this.jsx_parseIdentifier()
                          if (!t.allowNamespaces || !this.eat(qt.colon))
                            return s
                          var r = this.startNodeAt(e, i)
                          return (
                            (r.namespace = s),
                            (r.name = this.jsx_parseIdentifier()),
                            this.finishNode(r, 'JSXNamespacedName')
                          )
                        },
                      },
                      {
                        key: 'jsx_parseElementName',
                        value: function () {
                          if (this.type === Zt.jsxTagEnd) return ''
                          var e = this.start,
                            i = this.startLoc,
                            s = this.jsx_parseNamespacedName()
                          for (
                            this.type !== qt.dot ||
                            'JSXNamespacedName' !== s.type ||
                            t.allowNamespacedObjects ||
                            this.unexpected();
                            this.eat(qt.dot);

                          ) {
                            var r = this.startNodeAt(e, i)
                            ;(r.object = s),
                              (r.property = this.jsx_parseIdentifier()),
                              (s = this.finishNode(r, 'JSXMemberExpression'))
                          }
                          return s
                        },
                      },
                      {
                        key: 'jsx_parseAttributeValue',
                        value: function () {
                          switch (this.type) {
                            case qt.braceL:
                              var t = this.jsx_parseExpressionContainer()
                              return (
                                'JSXEmptyExpression' === t.expression.type &&
                                  this.raise(
                                    t.start,
                                    'JSX attributes must only be assigned a non-empty expression'
                                  ),
                                t
                              )
                            case Zt.jsxTagStart:
                            case qt.string:
                              return this.parseExprAtom()
                            default:
                              this.raise(
                                this.start,
                                'JSX value should be either an expression or a quoted JSX text'
                              )
                          }
                        },
                      },
                      {
                        key: 'jsx_parseEmptyExpression',
                        value: function () {
                          var t = this.startNodeAt(
                            this.lastTokEnd,
                            this.lastTokEndLoc
                          )
                          return this.finishNodeAt(
                            t,
                            'JSXEmptyExpression',
                            this.start,
                            this.startLoc
                          )
                        },
                      },
                      {
                        key: 'jsx_parseExpressionContainer',
                        value: function () {
                          var t = this.startNode()
                          return (
                            this.next(),
                            (t.expression =
                              this.type === qt.braceR
                                ? this.jsx_parseEmptyExpression()
                                : this.parseExpression()),
                            this.expect(qt.braceR),
                            this.finishNode(t, 'JSXExpressionContainer')
                          )
                        },
                      },
                      {
                        key: 'jsx_parseAttribute',
                        value: function () {
                          var t = this.startNode()
                          return this.eat(qt.braceL)
                            ? (this.expect(qt.ellipsis),
                              (t.argument = this.parseMaybeAssign()),
                              this.expect(qt.braceR),
                              this.finishNode(t, 'JSXSpreadAttribute'))
                            : ((t.name = this.jsx_parseNamespacedName()),
                              (t.value = this.eat(qt.eq)
                                ? this.jsx_parseAttributeValue()
                                : null),
                              this.finishNode(t, 'JSXAttribute'))
                        },
                      },
                      {
                        key: 'jsx_parseOpeningElementAt',
                        value: function (t, e) {
                          var i = this.startNodeAt(t, e)
                          i.attributes = []
                          var s = this.jsx_parseElementName()
                          for (
                            s && (i.name = s);
                            this.type !== qt.slash &&
                            this.type !== Zt.jsxTagEnd;

                          )
                            i.attributes.push(this.jsx_parseAttribute())
                          return (
                            (i.selfClosing = this.eat(qt.slash)),
                            this.expect(Zt.jsxTagEnd),
                            this.finishNode(
                              i,
                              s ? 'JSXOpeningElement' : 'JSXOpeningFragment'
                            )
                          )
                        },
                      },
                      {
                        key: 'jsx_parseClosingElementAt',
                        value: function (t, e) {
                          var i = this.startNodeAt(t, e),
                            s = this.jsx_parseElementName()
                          return (
                            s && (i.name = s),
                            this.expect(Zt.jsxTagEnd),
                            this.finishNode(
                              i,
                              s ? 'JSXClosingElement' : 'JSXClosingFragment'
                            )
                          )
                        },
                      },
                      {
                        key: 'jsx_parseElementAt',
                        value: function (t, e) {
                          var i = this.startNodeAt(t, e),
                            s = [],
                            r = this.jsx_parseOpeningElementAt(t, e),
                            n = null
                          if (!r.selfClosing) {
                            t: for (;;)
                              switch (this.type) {
                                case Zt.jsxTagStart:
                                  if (
                                    ((t = this.start),
                                    (e = this.startLoc),
                                    this.next(),
                                    this.eat(qt.slash))
                                  ) {
                                    n = this.jsx_parseClosingElementAt(t, e)
                                    break t
                                  }
                                  s.push(this.jsx_parseElementAt(t, e))
                                  break
                                case Zt.jsxText:
                                  s.push(this.parseExprAtom())
                                  break
                                case qt.braceL:
                                  s.push(this.jsx_parseExpressionContainer())
                                  break
                                default:
                                  this.unexpected()
                              }
                            Yt(n.name) !== Yt(r.name) &&
                              this.raise(
                                n.start,
                                'Expected corresponding JSX closing tag for <' +
                                  Yt(r.name) +
                                  '>'
                              )
                          }
                          var a = r.name ? 'Element' : 'Fragment'
                          return (
                            (i['opening' + a] = r),
                            (i['closing' + a] = n),
                            (i.children = s),
                            this.type === qt.relational &&
                              '<' === this.value &&
                              this.raise(
                                this.start,
                                'Adjacent JSX elements must be wrapped in an enclosing tag'
                              ),
                            this.finishNode(i, 'JSX' + a)
                          )
                        },
                      },
                      {
                        key: 'jsx_parseText',
                        value: function (t) {
                          var e = this.parseLiteral(t)
                          return (e.type = 'JSXText'), e
                        },
                      },
                      {
                        key: 'jsx_parseElement',
                        value: function () {
                          var t = this.start,
                            e = this.startLoc
                          return this.next(), this.jsx_parseElementAt(t, e)
                        },
                      },
                      {
                        key: 'parseExprAtom',
                        value: function (t) {
                          return this.type === Zt.jsxText
                            ? this.jsx_parseText(this.value)
                            : this.type === Zt.jsxTagStart
                            ? this.jsx_parseElement()
                            : Object(n.a)(
                                Object(p.a)(o.prototype),
                                'parseExprAtom',
                                this
                              ).call(this, t)
                        },
                      },
                      {
                        key: 'readToken',
                        value: function (t) {
                          var e = this.curContext()
                          if (e === $t) return this.jsx_readToken()
                          if (e === Qt || e === Kt) {
                            if (Ht(t)) return this.jsx_readWord()
                            if (62 == t)
                              return ++this.pos, this.finishToken(Zt.jsxTagEnd)
                            if ((34 === t || 39 === t) && e == Qt)
                              return this.jsx_readString(t)
                          }
                          return 60 === t &&
                            this.exprAllowed &&
                            33 !== this.input.charCodeAt(this.pos + 1)
                            ? (++this.pos, this.finishToken(Zt.jsxTagStart))
                            : Object(n.a)(
                                Object(p.a)(o.prototype),
                                'readToken',
                                this
                              ).call(this, t)
                        },
                      },
                      {
                        key: 'updateContext',
                        value: function (t) {
                          if (this.type == qt.braceL) {
                            var e = this.curContext()
                            e == Qt
                              ? this.context.push(Xt.b_expr)
                              : e == $t
                              ? this.context.push(Xt.b_tmpl)
                              : Object(n.a)(
                                  Object(p.a)(o.prototype),
                                  'updateContext',
                                  this
                                ).call(this, t),
                              (this.exprAllowed = !0)
                          } else {
                            if (this.type !== qt.slash || t !== Zt.jsxTagStart)
                              return Object(n.a)(
                                Object(p.a)(o.prototype),
                                'updateContext',
                                this
                              ).call(this, t)
                            ;(this.context.length -= 2),
                              this.context.push(Kt),
                              (this.exprAllowed = !1)
                          }
                        },
                      },
                    ]),
                    o
                  )
                })(e)
              })(
                {
                  allowNamespaces: !1 !== t.allowNamespaces,
                  allowNamespacedObjects: !!t.allowNamespacedObjects,
                },
                e
              )
            }
          )
        }
        te.tokTypes = Zt
        var ee,
          ie,
          se =
            ((function (t, e) {
              Object.defineProperty(e, '__esModule', { value: !0 }),
                (e.DynamicImportKey = void 0)
              var i = (function () {
                  function t(t, e) {
                    for (var i = 0; i < e.length; i++) {
                      var s = e[i]
                      ;(s.enumerable = s.enumerable || !1),
                        (s.configurable = !0),
                        'value' in s && (s.writable = !0),
                        Object.defineProperty(t, s.key, s)
                    }
                  }
                  return function (e, i, s) {
                    return i && t(e.prototype, i), s && t(e, s), e
                  }
                })(),
                s = function t(e, i, s) {
                  null === e && (e = Function.prototype)
                  var r = Object.getOwnPropertyDescriptor(e, i)
                  if (void 0 === r) {
                    var n = Object.getPrototypeOf(e)
                    return null === n ? void 0 : t(n, i, s)
                  }
                  if ('value' in r) return r.value
                  var a = r.get
                  return void 0 !== a ? a.call(s) : void 0
                }
              e.default = function (t) {
                return (function (e) {
                  function n() {
                    return (
                      (function (t, e) {
                        if (!(t instanceof n))
                          throw new TypeError(
                            'Cannot call a class as a function'
                          )
                      })(this),
                      (function (t, e) {
                        if (!t)
                          throw new ReferenceError(
                            "this hasn't been initialised - super() hasn't been called"
                          )
                        return !e ||
                          ('object' != typeof e && 'function' != typeof e)
                          ? t
                          : e
                      })(
                        this,
                        (n.__proto__ || Object.getPrototypeOf(n)).apply(
                          this,
                          arguments
                        )
                      )
                    )
                  }
                  return (
                    (function (t, e) {
                      if ('function' != typeof e && null !== e)
                        throw new TypeError(
                          'Super expression must either be null or a function, not ' +
                            typeof e
                        )
                      ;(t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                          value: t,
                          enumerable: !1,
                          writable: !0,
                          configurable: !0,
                        },
                      })),
                        e &&
                          (Object.setPrototypeOf
                            ? Object.setPrototypeOf(t, e)
                            : (t.__proto__ = e))
                    })(n, t),
                    i(n, [
                      {
                        key: 'parseStatement',
                        value: function (t, e, i) {
                          return this.type === Ft.tokTypes._import &&
                            function () {
                              return /^(\s|\/\/.*|\/\*[^]*?\*\/)*\(/.test(
                                this.input.slice(this.pos)
                              )
                            }.call(this)
                            ? this.parseExpressionStatement(
                                this.startNode(),
                                this.parseExpression()
                              )
                            : s(
                                n.prototype.__proto__ ||
                                  Object.getPrototypeOf(n.prototype),
                                'parseStatement',
                                this
                              ).call(this, t, e, i)
                        },
                      },
                      {
                        key: 'parseExprAtom',
                        value: function (t) {
                          return this.type === Ft.tokTypes._import
                            ? function () {
                                var t = this.startNode()
                                return (
                                  this.next(),
                                  this.type !== Ft.tokTypes.parenL &&
                                    this.unexpected(),
                                  this.finishNode(t, r)
                                )
                              }.call(this)
                            : s(
                                n.prototype.__proto__ ||
                                  Object.getPrototypeOf(n.prototype),
                                'parseExprAtom',
                                this
                              ).call(this, t)
                        },
                      },
                    ]),
                    n
                  )
                })()
              }
              var r = (e.DynamicImportKey = 'Import')
              Ft.tokTypes._import.startsExpr = !0
            })((ee = { exports: {} }), ee.exports),
            (ie = ee.exports) &&
            ie.__esModule &&
            Object.prototype.hasOwnProperty.call(ie, 'default')
              ? ie.default
              : ie),
          re = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
          ne = Ft.tokTypes
        function ae(t) {
          if (this.eat(ne.eq)) {
            var e = this._inFieldValue
            ;(this._inFieldValue = !0),
              (t.value = this.parseExpression()),
              (this._inFieldValue = e)
          } else t.value = null
        }
        function oe() {
          var t = this.startNode()
          return (
            (t.name = this.value),
            this.next(),
            this.finishNode(t, 'PrivateName'),
            'never' == this.options.allowReserved && this.checkUnreserved(t),
            t
          )
        }
        var pe = new (0, Ft.TokenType)('privateName')
        function he(t) {
          var e = ''
          t = t < 0 ? (-t << 1) | 1 : t << 1
          do {
            var i = 31 & t
            ;(t >>= 5) > 0 && (i |= 32),
              (e += 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='[
                i
              ])
          } while (t > 0)
          return e
        }
        var ce = function (t, e, i) {
          ;(this.start = t),
            (this.end = e),
            (this.original = i),
            (this.intro = ''),
            (this.outro = ''),
            (this.content = i),
            (this.storeName = !1),
            (this.edited = !1),
            Object.defineProperties(this, {
              previous: { writable: !0, value: null },
              next: { writable: !0, value: null },
            })
        }
        ;(ce.prototype.appendLeft = function (t) {
          this.outro += t
        }),
          (ce.prototype.appendRight = function (t) {
            this.intro = this.intro + t
          }),
          (ce.prototype.clone = function () {
            var t = new ce(this.start, this.end, this.original)
            return (
              (t.intro = this.intro),
              (t.outro = this.outro),
              (t.content = this.content),
              (t.storeName = this.storeName),
              (t.edited = this.edited),
              t
            )
          }),
          (ce.prototype.contains = function (t) {
            return this.start < t && t < this.end
          }),
          (ce.prototype.eachNext = function (t) {
            for (var e = this; e; ) t(e), (e = e.next)
          }),
          (ce.prototype.eachPrevious = function (t) {
            for (var e = this; e; ) t(e), (e = e.previous)
          }),
          (ce.prototype.edit = function (t, e, i) {
            return (
              (this.content = t),
              i || ((this.intro = ''), (this.outro = '')),
              (this.storeName = e),
              (this.edited = !0),
              this
            )
          }),
          (ce.prototype.prependLeft = function (t) {
            this.outro = t + this.outro
          }),
          (ce.prototype.prependRight = function (t) {
            this.intro = t + this.intro
          }),
          (ce.prototype.split = function (t) {
            var e = t - this.start,
              i = this.original.slice(0, e),
              s = this.original.slice(e)
            this.original = i
            var r = new ce(t, this.end, s)
            return (
              (r.outro = this.outro),
              (this.outro = ''),
              (this.end = t),
              this.edited
                ? (r.edit('', !1), (this.content = ''))
                : (this.content = i),
              (r.next = this.next),
              r.next && (r.next.previous = r),
              (r.previous = this),
              (this.next = r),
              r
            )
          }),
          (ce.prototype.toString = function () {
            return this.intro + this.content + this.outro
          }),
          (ce.prototype.trimEnd = function (t) {
            if (((this.outro = this.outro.replace(t, '')), this.outro.length))
              return !0
            var e = this.content.replace(t, '')
            return e.length
              ? (e !== this.content &&
                  this.split(this.start + e.length).edit('', void 0, !0),
                !0)
              : (this.edit('', void 0, !0),
                (this.intro = this.intro.replace(t, '')),
                !!this.intro.length || void 0)
          }),
          (ce.prototype.trimStart = function (t) {
            if (((this.intro = this.intro.replace(t, '')), this.intro.length))
              return !0
            var e = this.content.replace(t, '')
            return e.length
              ? (e !== this.content &&
                  (this.split(this.end - e.length), this.edit('', void 0, !0)),
                !0)
              : (this.edit('', void 0, !0),
                (this.outro = this.outro.replace(t, '')),
                !!this.outro.length || void 0)
          })
        var le = function () {
          throw new Error(
            'Unsupported environment: `window.btoa` or `Buffer` should be supported.'
          )
        }
        'undefined' != typeof window && 'function' == typeof window.btoa
          ? (le = function (t) {
              return window.btoa(unescape(encodeURIComponent(t)))
            })
          : 'function' == typeof t &&
            (le = function (e) {
              return t.from(e, 'utf-8').toString('base64')
            })
        var ue = function (t) {
          ;(this.version = 3),
            (this.file = t.file),
            (this.sources = t.sources),
            (this.sourcesContent = t.sourcesContent),
            (this.names = t.names),
            (this.mappings = (function (t) {
              for (
                var e = 0, i = 0, s = 0, r = 0, n = '', a = 0;
                a < t.length;
                a++
              ) {
                var o = t[a]
                if ((a > 0 && (n += ';'), 0 !== o.length)) {
                  for (var p = 0, h = [], c = 0, l = o; c < l.length; c++) {
                    var u = l[c],
                      d = he(u[0] - p)
                    ;(p = u[0]),
                      u.length > 1 &&
                        ((d += he(u[1] - e) + he(u[2] - i) + he(u[3] - s)),
                        (e = u[1]),
                        (i = u[2]),
                        (s = u[3])),
                      5 === u.length && ((d += he(u[4] - r)), (r = u[4])),
                      h.push(d)
                  }
                  n += h.join(',')
                }
              }
              return n
            })(t.mappings))
        }
        function de(t) {
          var e = t.split('\n'),
            i = e.filter(function (t) {
              return /^\t+/.test(t)
            }),
            s = e.filter(function (t) {
              return /^ {2,}/.test(t)
            })
          if (0 === i.length && 0 === s.length) return null
          if (i.length >= s.length) return '\t'
          var r = s.reduce(function (t, e) {
            var i = /^ +/.exec(e)[0].length
            return Math.min(i, t)
          }, 1 / 0)
          return new Array(r + 1).join(' ')
        }
        function fe(t, e) {
          var i = t.split(/[\/\\]/),
            s = e.split(/[\/\\]/)
          for (i.pop(); i[0] === s[0]; ) i.shift(), s.shift()
          if (i.length) for (var r = i.length; r--; ) i[r] = '..'
          return i.concat(s).join('/')
        }
        ;(ue.prototype.toString = function () {
          return JSON.stringify(this)
        }),
          (ue.prototype.toUrl = function () {
            return (
              'data:application/json;charset=utf-8;base64,' +
              le(this.toString())
            )
          })
        var me = Object.prototype.toString
        function ye(t) {
          for (var e = t.split('\n'), i = [], s = 0, r = 0; s < e.length; s++)
            i.push(r), (r += e[s].length + 1)
          return function (t) {
            for (var e = 0, s = i.length; e < s; ) {
              var r = (e + s) >> 1
              t < i[r] ? (s = r) : (e = r + 1)
            }
            var n = e - 1
            return { line: n, column: t - i[n] }
          }
        }
        var ge = function (t) {
          ;(this.hires = t),
            (this.generatedCodeLine = 0),
            (this.generatedCodeColumn = 0),
            (this.raw = []),
            (this.rawSegments = this.raw[this.generatedCodeLine] = []),
            (this.pending = null)
        }
        ;(ge.prototype.addEdit = function (t, e, i, s) {
          if (e.length) {
            var r = [this.generatedCodeColumn, t, i.line, i.column]
            s >= 0 && r.push(s), this.rawSegments.push(r)
          } else this.pending && this.rawSegments.push(this.pending)
          this.advance(e), (this.pending = null)
        }),
          (ge.prototype.addUneditedChunk = function (t, e, i, s, r) {
            for (var n = e.start, a = !0; n < e.end; )
              (this.hires || a || r[n]) &&
                this.rawSegments.push([
                  this.generatedCodeColumn,
                  t,
                  s.line,
                  s.column,
                ]),
                '\n' === i[n]
                  ? ((s.line += 1),
                    (s.column = 0),
                    (this.generatedCodeLine += 1),
                    (this.raw[this.generatedCodeLine] = this.rawSegments = []),
                    (this.generatedCodeColumn = 0))
                  : ((s.column += 1), (this.generatedCodeColumn += 1)),
                (n += 1),
                (a = !1)
            this.pending = [this.generatedCodeColumn, t, s.line, s.column]
          }),
          (ge.prototype.advance = function (t) {
            if (t) {
              var e = t.split('\n')
              if (e.length > 1) {
                for (var i = 0; i < e.length - 1; i++)
                  this.generatedCodeLine++,
                    (this.raw[this.generatedCodeLine] = this.rawSegments = [])
                this.generatedCodeColumn = 0
              }
              this.generatedCodeColumn += e[e.length - 1].length
            }
          })
        var ve = { insertLeft: !1, insertRight: !1, storeName: !1 },
          xe = function (t, e) {
            void 0 === e && (e = {})
            var i = new ce(0, t.length, t)
            Object.defineProperties(this, {
              original: { writable: !0, value: t },
              outro: { writable: !0, value: '' },
              intro: { writable: !0, value: '' },
              firstChunk: { writable: !0, value: i },
              lastChunk: { writable: !0, value: i },
              lastSearchedChunk: { writable: !0, value: i },
              byStart: { writable: !0, value: {} },
              byEnd: { writable: !0, value: {} },
              filename: { writable: !0, value: e.filename },
              indentExclusionRanges: {
                writable: !0,
                value: e.indentExclusionRanges,
              },
              sourcemapLocations: { writable: !0, value: {} },
              storedNames: { writable: !0, value: {} },
              indentStr: { writable: !0, value: de(t) },
            }),
              (this.byStart[0] = i),
              (this.byEnd[t.length] = i)
          }
        function be(t) {
          var e = {}
          return (
            Object.keys(t).forEach(function (i) {
              'parent' !== i &&
                'program' !== i &&
                'keys' !== i &&
                '__wrapped' !== i &&
                (e[i] = Array.isArray(t[i])
                  ? t[i].map(be)
                  : t[i] && t[i].toJSON
                  ? t[i].toJSON()
                  : t[i])
            }),
            e
          )
        }
        ;(xe.prototype.addSourcemapLocation = function (t) {
          this.sourcemapLocations[t] = !0
        }),
          (xe.prototype.append = function (t) {
            if ('string' != typeof t)
              throw new TypeError('outro content must be a string')
            return (this.outro += t), this
          }),
          (xe.prototype.appendLeft = function (t, e) {
            if ('string' != typeof e)
              throw new TypeError('inserted content must be a string')
            this._split(t)
            var i = this.byEnd[t]
            return i ? i.appendLeft(e) : (this.intro += e), this
          }),
          (xe.prototype.appendRight = function (t, e) {
            if ('string' != typeof e)
              throw new TypeError('inserted content must be a string')
            this._split(t)
            var i = this.byStart[t]
            return i ? i.appendRight(e) : (this.outro += e), this
          }),
          (xe.prototype.clone = function () {
            for (
              var t = new xe(this.original, { filename: this.filename }),
                e = this.firstChunk,
                i = (t.firstChunk = t.lastSearchedChunk = e.clone());
              e;

            ) {
              ;(t.byStart[i.start] = i), (t.byEnd[i.end] = i)
              var s = e.next,
                r = s && s.clone()
              r && ((i.next = r), (r.previous = i), (i = r)), (e = s)
            }
            return (
              (t.lastChunk = i),
              this.indentExclusionRanges &&
                (t.indentExclusionRanges = this.indentExclusionRanges.slice()),
              Object.keys(this.sourcemapLocations).forEach(function (e) {
                t.sourcemapLocations[e] = !0
              }),
              t
            )
          }),
          (xe.prototype.generateDecodedMap = function (t) {
            var e = this
            t = t || {}
            var i = Object.keys(this.storedNames),
              s = new ge(t.hires),
              r = ye(this.original)
            return (
              this.intro && s.advance(this.intro),
              this.firstChunk.eachNext(function (t) {
                var n = r(t.start)
                t.intro.length && s.advance(t.intro),
                  t.edited
                    ? s.addEdit(
                        0,
                        t.content,
                        n,
                        t.storeName ? i.indexOf(t.original) : -1
                      )
                    : s.addUneditedChunk(
                        0,
                        t,
                        e.original,
                        n,
                        e.sourcemapLocations
                      ),
                  t.outro.length && s.advance(t.outro)
              }),
              {
                file: t.file ? t.file.split(/[\/\\]/).pop() : null,
                sources: [t.source ? fe(t.file || '', t.source) : null],
                sourcesContent: t.includeContent ? [this.original] : [null],
                names: i,
                mappings: s.raw,
              }
            )
          }),
          (xe.prototype.generateMap = function (t) {
            return new ue(this.generateDecodedMap(t))
          }),
          (xe.prototype.getIndentString = function () {
            return null === this.indentStr ? '\t' : this.indentStr
          }),
          (xe.prototype.indent = function (t, e) {
            var i = /^[^\r\n]/gm
            if (
              ('[object Object]' === me.call(t) && ((e = t), (t = void 0)),
              '' === (t = void 0 !== t ? t : this.indentStr || '\t'))
            )
              return this
            var s = {}
            ;(e = e || {}).exclude &&
              ('number' == typeof e.exclude[0]
                ? [e.exclude]
                : e.exclude
              ).forEach(function (t) {
                for (var e = t[0]; e < t[1]; e += 1) s[e] = !0
              })
            var r = !1 !== e.indentStart,
              n = function (e) {
                return r ? '' + t + e : ((r = !0), e)
              }
            this.intro = this.intro.replace(i, n)
            for (var a = 0, o = this.firstChunk; o; ) {
              var p = o.end
              if (o.edited)
                s[a] ||
                  ((o.content = o.content.replace(i, n)),
                  o.content.length &&
                    (r = '\n' === o.content[o.content.length - 1]))
              else
                for (a = o.start; a < p; ) {
                  if (!s[a]) {
                    var h = this.original[a]
                    '\n' === h
                      ? (r = !0)
                      : '\r' !== h &&
                        r &&
                        ((r = !1),
                        a === o.start
                          ? o.prependRight(t)
                          : (this._splitChunk(o, a),
                            (o = o.next).prependRight(t)))
                  }
                  a += 1
                }
              ;(a = o.end), (o = o.next)
            }
            return (this.outro = this.outro.replace(i, n)), this
          }),
          (xe.prototype.insert = function () {
            throw new Error(
              'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'
            )
          }),
          (xe.prototype.insertLeft = function (t, e) {
            return (
              ve.insertLeft ||
                (console.warn(
                  'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'
                ),
                (ve.insertLeft = !0)),
              this.appendLeft(t, e)
            )
          }),
          (xe.prototype.insertRight = function (t, e) {
            return (
              ve.insertRight ||
                (console.warn(
                  'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'
                ),
                (ve.insertRight = !0)),
              this.prependRight(t, e)
            )
          }),
          (xe.prototype.move = function (t, e, i) {
            if (i >= t && i <= e)
              throw new Error('Cannot move a selection inside itself')
            this._split(t), this._split(e), this._split(i)
            var s = this.byStart[t],
              r = this.byEnd[e],
              n = s.previous,
              a = r.next,
              o = this.byStart[i]
            if (!o && r === this.lastChunk) return this
            var p = o ? o.previous : this.lastChunk
            return (
              n && (n.next = a),
              a && (a.previous = n),
              p && (p.next = s),
              o && (o.previous = r),
              s.previous || (this.firstChunk = r.next),
              r.next ||
                ((this.lastChunk = s.previous), (this.lastChunk.next = null)),
              (s.previous = p),
              (r.next = o || null),
              p || (this.firstChunk = s),
              o || (this.lastChunk = r),
              this
            )
          }),
          (xe.prototype.overwrite = function (t, e, i, s) {
            if ('string' != typeof i)
              throw new TypeError('replacement content must be a string')
            for (; t < 0; ) t += this.original.length
            for (; e < 0; ) e += this.original.length
            if (e > this.original.length)
              throw new Error('end is out of bounds')
            if (t === e)
              throw new Error(
                'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'
              )
            this._split(t),
              this._split(e),
              !0 === s &&
                (ve.storeName ||
                  (console.warn(
                    'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'
                  ),
                  (ve.storeName = !0)),
                (s = { storeName: !0 }))
            var r = void 0 !== s && s.storeName,
              n = void 0 !== s && s.contentOnly
            if (r) {
              var a = this.original.slice(t, e)
              this.storedNames[a] = !0
            }
            var o = this.byStart[t],
              p = this.byEnd[e]
            if (o) {
              if (e > o.end && o.next !== this.byStart[o.end])
                throw new Error('Cannot overwrite across a split point')
              if ((o.edit(i, r, n), o !== p)) {
                for (var h = o.next; h !== p; ) h.edit('', !1), (h = h.next)
                h.edit('', !1)
              }
            } else {
              var c = new ce(t, e, '').edit(i, r)
              ;(p.next = c), (c.previous = p)
            }
            return this
          }),
          (xe.prototype.prepend = function (t) {
            if ('string' != typeof t)
              throw new TypeError('outro content must be a string')
            return (this.intro = t + this.intro), this
          }),
          (xe.prototype.prependLeft = function (t, e) {
            if ('string' != typeof e)
              throw new TypeError('inserted content must be a string')
            this._split(t)
            var i = this.byEnd[t]
            return i ? i.prependLeft(e) : (this.intro = e + this.intro), this
          }),
          (xe.prototype.prependRight = function (t, e) {
            if ('string' != typeof e)
              throw new TypeError('inserted content must be a string')
            this._split(t)
            var i = this.byStart[t]
            return i ? i.prependRight(e) : (this.outro = e + this.outro), this
          }),
          (xe.prototype.remove = function (t, e) {
            for (; t < 0; ) t += this.original.length
            for (; e < 0; ) e += this.original.length
            if (t === e) return this
            if (t < 0 || e > this.original.length)
              throw new Error('Character is out of bounds')
            if (t > e) throw new Error('end must be greater than start')
            this._split(t), this._split(e)
            for (var i = this.byStart[t]; i; )
              (i.intro = ''),
                (i.outro = ''),
                i.edit(''),
                (i = e > i.end ? this.byStart[i.end] : null)
            return this
          }),
          (xe.prototype.lastChar = function () {
            if (this.outro.length) return this.outro[this.outro.length - 1]
            var t = this.lastChunk
            do {
              if (t.outro.length) return t.outro[t.outro.length - 1]
              if (t.content.length) return t.content[t.content.length - 1]
              if (t.intro.length) return t.intro[t.intro.length - 1]
            } while ((t = t.previous))
            return this.intro.length ? this.intro[this.intro.length - 1] : ''
          }),
          (xe.prototype.lastLine = function () {
            var t = this.outro.lastIndexOf('\n')
            if (-1 !== t) return this.outro.substr(t + 1)
            var e = this.outro,
              i = this.lastChunk
            do {
              if (i.outro.length > 0) {
                if (-1 !== (t = i.outro.lastIndexOf('\n')))
                  return i.outro.substr(t + 1) + e
                e = i.outro + e
              }
              if (i.content.length > 0) {
                if (-1 !== (t = i.content.lastIndexOf('\n')))
                  return i.content.substr(t + 1) + e
                e = i.content + e
              }
              if (i.intro.length > 0) {
                if (-1 !== (t = i.intro.lastIndexOf('\n')))
                  return i.intro.substr(t + 1) + e
                e = i.intro + e
              }
            } while ((i = i.previous))
            return -1 !== (t = this.intro.lastIndexOf('\n'))
              ? this.intro.substr(t + 1) + e
              : this.intro + e
          }),
          (xe.prototype.slice = function (t, e) {
            for (
              void 0 === t && (t = 0),
                void 0 === e && (e = this.original.length);
              t < 0;

            )
              t += this.original.length
            for (; e < 0; ) e += this.original.length
            for (
              var i = '', s = this.firstChunk;
              s && (s.start > t || s.end <= t);

            ) {
              if (s.start < e && s.end >= e) return i
              s = s.next
            }
            if (s && s.edited && s.start !== t)
              throw new Error(
                'Cannot use replaced character ' + t + ' as slice start anchor.'
              )
            for (var r = s; s; ) {
              !s.intro || (r === s && s.start !== t) || (i += s.intro)
              var n = s.start < e && s.end >= e
              if (n && s.edited && s.end !== e)
                throw new Error(
                  'Cannot use replaced character ' + e + ' as slice end anchor.'
                )
              if (
                ((i += s.content.slice(
                  r === s ? t - s.start : 0,
                  n ? s.content.length + e - s.end : s.content.length
                )),
                !s.outro || (n && s.end !== e) || (i += s.outro),
                n)
              )
                break
              s = s.next
            }
            return i
          }),
          (xe.prototype.snip = function (t, e) {
            var i = this.clone()
            return i.remove(0, t), i.remove(e, i.original.length), i
          }),
          (xe.prototype._split = function (t) {
            if (!this.byStart[t] && !this.byEnd[t])
              for (var e = this.lastSearchedChunk, i = t > e.end; e; ) {
                if (e.contains(t)) return this._splitChunk(e, t)
                e = i ? this.byStart[e.end] : this.byEnd[e.start]
              }
          }),
          (xe.prototype._splitChunk = function (t, e) {
            if (t.edited && t.content.length) {
              var i = ye(this.original)(e)
              throw new Error(
                'Cannot split a chunk that has already been edited (' +
                  i.line +
                  ':' +
                  i.column +
                  ' – "' +
                  t.original +
                  '")'
              )
            }
            var s = t.split(e)
            return (
              (this.byEnd[e] = t),
              (this.byStart[e] = s),
              (this.byEnd[s.end] = s),
              t === this.lastChunk && (this.lastChunk = s),
              (this.lastSearchedChunk = t),
              !0
            )
          }),
          (xe.prototype.toString = function () {
            for (var t = this.intro, e = this.firstChunk; e; )
              (t += e.toString()), (e = e.next)
            return t + this.outro
          }),
          (xe.prototype.isEmpty = function () {
            var t = this.firstChunk
            do {
              if (
                (t.intro.length && t.intro.trim()) ||
                (t.content.length && t.content.trim()) ||
                (t.outro.length && t.outro.trim())
              )
                return !1
            } while ((t = t.next))
            return !0
          }),
          (xe.prototype.length = function () {
            var t = this.firstChunk,
              e = 0
            do {
              e += t.intro.length + t.content.length + t.outro.length
            } while ((t = t.next))
            return e
          }),
          (xe.prototype.trimLines = function () {
            return this.trim('[\\r\\n]')
          }),
          (xe.prototype.trim = function (t) {
            return this.trimStart(t).trimEnd(t)
          }),
          (xe.prototype.trimEndAborted = function (t) {
            var e = new RegExp((t || '\\s') + '+$')
            if (((this.outro = this.outro.replace(e, '')), this.outro.length))
              return !0
            var i = this.lastChunk
            do {
              var s = i.end,
                r = i.trimEnd(e)
              if (
                (i.end !== s &&
                  (this.lastChunk === i && (this.lastChunk = i.next),
                  (this.byEnd[i.end] = i),
                  (this.byStart[i.next.start] = i.next),
                  (this.byEnd[i.next.end] = i.next)),
                r)
              )
                return !0
              i = i.previous
            } while (i)
            return !1
          }),
          (xe.prototype.trimEnd = function (t) {
            return this.trimEndAborted(t), this
          }),
          (xe.prototype.trimStartAborted = function (t) {
            var e = new RegExp('^' + (t || '\\s') + '+')
            if (((this.intro = this.intro.replace(e, '')), this.intro.length))
              return !0
            var i = this.firstChunk
            do {
              var s = i.end,
                r = i.trimStart(e)
              if (
                (i.end !== s &&
                  (i === this.lastChunk && (this.lastChunk = i.next),
                  (this.byEnd[i.end] = i),
                  (this.byStart[i.next.start] = i.next),
                  (this.byEnd[i.next.end] = i.next)),
                r)
              )
                return !0
              i = i.next
            } while (i)
            return !1
          }),
          (xe.prototype.trimStart = function (t) {
            return this.trimStartAborted(t), this
          })
        var _e = function () {}
        function ke(t) {
          var e = []
          return Se[t.type](e, t), e
        }
        ;(_e.prototype.ancestor = function (t) {
          for (var e = this; t--; ) if (!(e = e.parent)) return null
          return e
        }),
          (_e.prototype.contains = function (t) {
            for (; t; ) {
              if (t === this) return !0
              t = t.parent
            }
            return !1
          }),
          (_e.prototype.findLexicalBoundary = function () {
            return this.parent.findLexicalBoundary()
          }),
          (_e.prototype.findNearest = function (t) {
            return (
              'string' == typeof t && (t = new RegExp('^' + t + '$')),
              t.test(this.type) ? this : this.parent.findNearest(t)
            )
          }),
          (_e.prototype.unparenthesizedParent = function () {
            for (
              var t = this.parent;
              t && 'ParenthesizedExpression' === t.type;

            )
              t = t.parent
            return t
          }),
          (_e.prototype.unparenthesize = function () {
            for (var t = this; 'ParenthesizedExpression' === t.type; )
              t = t.expression
            return t
          }),
          (_e.prototype.findScope = function (t) {
            return this.parent.findScope(t)
          }),
          (_e.prototype.getIndentation = function () {
            return this.parent.getIndentation()
          }),
          (_e.prototype.initialise = function (t) {
            for (var e = 0, i = this.keys; e < i.length; e += 1) {
              var s = this[i[e]]
              Array.isArray(s)
                ? s.forEach(function (e) {
                    return e && e.initialise(t)
                  })
                : s && 'object' == typeof s && s.initialise(t)
            }
          }),
          (_e.prototype.toJSON = function () {
            return be(this)
          }),
          (_e.prototype.toString = function () {
            return this.program.magicString.original.slice(this.start, this.end)
          }),
          (_e.prototype.transpile = function (t, e) {
            for (var i = 0, s = this.keys; i < s.length; i += 1) {
              var r = this[s[i]]
              Array.isArray(r)
                ? r.forEach(function (i) {
                    return i && i.transpile(t, e)
                  })
                : r && 'object' == typeof r && r.transpile(t, e)
            }
          })
        var Se = {
            Identifier: function (t, e) {
              t.push(e)
            },
            ObjectPattern: function (t, e) {
              for (var i = 0, s = e.properties; i < s.length; i += 1) {
                var r = s[i]
                Se[r.type](t, r)
              }
            },
            Property: function (t, e) {
              Se[e.value.type](t, e.value)
            },
            ArrayPattern: function (t, e) {
              for (var i = 0, s = e.elements; i < s.length; i += 1) {
                var r = s[i]
                r && Se[r.type](t, r)
              }
            },
            RestElement: function (t, e) {
              Se[e.argument.type](t, e.argument)
            },
            AssignmentPattern: function (t, e) {
              Se[e.left.type](t, e.left)
            },
          },
          we = Object.create(null)
        function Ee(t) {
          ;(this.parent = (t = t || {}).parent),
            (this.isBlockScope = !!t.block),
            (this.createDeclarationCallback = t.declare)
          for (var e = this; e.isBlockScope; ) e = e.parent
          ;(this.functionScope = e),
            (this.identifiers = []),
            (this.declarations = Object.create(null)),
            (this.references = Object.create(null)),
            (this.blockScopedDeclarations = this.isBlockScope
              ? null
              : Object.create(null)),
            (this.aliases = Object.create(null))
        }
        function Ce(t, e) {
          for (var i = ''; e--; ) i += t
          return i
        }
        function Ae(t, e, i) {
          void 0 === i && (i = 1)
          var s = Math.max(e.line - 5, 0),
            r = e.line,
            n = String(r).length,
            a = t.split('\n').slice(s, r),
            o = a[a.length - 1].slice(0, e.column).replace(/\t/g, '  ').length
          return (
            a
              .map(function (t, e) {
                return (
                  (i = n),
                  (r = String(e + s + 1)) +
                    Ce(' ', i - r.length) +
                    ' : ' +
                    t.replace(/\t/g, '  ')
                )
                var i, r
              })
              .join('\n') +
            '\n' +
            Ce(' ', n + 3 + o) +
            Ce('^', i)
          )
        }
        'do if in for let new try var case else enum eval null this true void with await break catch class const false super throw while yield delete export import public return static switch typeof default extends finally package private continue debugger function arguments interface protected implements instanceof'
          .split(' ')
          .forEach(function (t) {
            return (we[t] = !0)
          }),
          (Ee.prototype = {
            addDeclaration: function (t, e) {
              for (var i = 0, s = ke(t); i < s.length; i += 1) {
                var r = s[i],
                  n = r.name,
                  a = { name: n, node: r, kind: e, instances: [] }
                ;(this.declarations[n] = a),
                  this.isBlockScope &&
                    (this.functionScope.blockScopedDeclarations[n] ||
                      (this.functionScope.blockScopedDeclarations[n] = []),
                    this.functionScope.blockScopedDeclarations[n].push(a))
              }
            },
            addReference: function (t) {
              this.consolidated
                ? this.consolidateReference(t)
                : this.identifiers.push(t)
            },
            consolidate: function () {
              for (var t = 0; t < this.identifiers.length; t += 1)
                this.consolidateReference(this.identifiers[t])
              this.consolidated = !0
            },
            consolidateReference: function (t) {
              var e = this.declarations[t.name]
              e
                ? e.instances.push(t)
                : ((this.references[t.name] = !0),
                  this.parent && this.parent.addReference(t))
            },
            contains: function (t) {
              return (
                this.declarations[t] ||
                (!!this.parent && this.parent.contains(t))
              )
            },
            createIdentifier: function (t) {
              'number' == typeof t && (t = t.toString())
              for (
                var e = (t = t
                    .replace(/\s/g, '')
                    .replace(/\[([^\]]+)\]/g, '_$1')
                    .replace(/[^a-zA-Z0-9_$]/g, '_')
                    .replace(/_{2,}/, '_')),
                  i = 1;
                this.declarations[e] ||
                this.references[e] ||
                this.aliases[e] ||
                e in we;

              )
                e = t + '$' + i++
              return (this.aliases[e] = !0), e
            },
            createDeclaration: function (t) {
              var e = this.createIdentifier(t)
              return this.createDeclarationCallback(e), e
            },
            findDeclaration: function (t) {
              return (
                this.declarations[t] ||
                (this.parent && this.parent.findDeclaration(t))
              )
            },
            resolveName: function (t) {
              var e = this.findDeclaration(t)
              return e ? e.name : t
            },
          })
        var Ie = (function (t) {
          function e(e, i) {
            if ((t.call(this, e), (this.name = 'CompileError'), i)) {
              var s = i.program.magicString.original,
                r = (function (t, e) {
                  var i,
                    s = t.split('\n'),
                    r = s.length,
                    n = 0
                  for (i = 0; i < r; i += 1) {
                    var a = n + s[i].length + 1
                    if (a > e) return { line: i + 1, column: e - n, char: i }
                    n = a
                  }
                  throw new Error('Could not determine location of character')
                })(s, i.start)
              ;(this.message = e + ' (' + r.line + ':' + r.column + ')'),
                (this.stack = new t().stack.replace(
                  new RegExp('.+new ' + this.name + '.+\\n', 'm'),
                  ''
                )),
                (this.loc = r),
                (this.snippet = Ae(s, r, i.end - i.start))
            }
          }
          return (
            t && (e.__proto__ = t),
            ((e.prototype = Object.create(t && t.prototype)).constructor = e),
            (e.prototype.toString = function () {
              return this.name + ': ' + this.message + '\n' + this.snippet
            }),
            (e.missingTransform = function (t, i, s, r) {
              throw (
                (void 0 === r && (r = null),
                new e(
                  'Transforming ' +
                    t +
                    ' is not ' +
                    (r ? 'fully supported' : 'implemented') +
                    '. Use `transforms: { ' +
                    i +
                    ': false }` to skip transformation and disable this error' +
                    (r
                      ? ', or `transforms: { ' +
                        r +
                        ": true }` if you know what you're doing"
                      : '') +
                    '.',
                  s
                ))
              )
            }),
            e
          )
        })(Error)
        function Le(t, e) {
          for (var i = 0; i < t.length; i += 1) if (e(t[i], i)) return i
          return -1
        }
        var Pe = {
          Identifier: Oe,
          AssignmentPattern: function (t, e, i, s, r, n, a) {
            var o = 'Identifier' === s.left.type,
              p = o ? s.left.name : r
            n ||
              a.push(function (e, i, r) {
                t.prependRight(
                  s.left.end,
                  i + 'if ( ' + p + ' === void 0 ) ' + p
                ),
                  t.move(s.left.end, s.right.end, e),
                  t.appendLeft(s.right.end, r)
              }),
              o || Ne(t, e, i, s.left, r, n, a)
          },
          ArrayPattern: function (t, e, i, s, r, n, a) {
            var o = s.start
            s.elements.forEach(function (s, p) {
              s &&
                ('RestElement' === s.type
                  ? Te(t, e, i, o, s.argument, r + '.slice(' + p + ')', n, a)
                  : Te(t, e, i, o, s, r + '[' + p + ']', n, a),
                (o = s.end))
            }),
              t.remove(o, s.end)
          },
          ObjectPattern: je,
        }
        function Ne(t, e, i, s, r, n, a) {
          Pe[s.type](t, e, i, s, r, n, a)
        }
        function Oe(t, e, i, s, r, n, a) {
          a.push(function (e, a, o) {
            t.overwrite(
              s.start,
              s.end,
              (n ? a : a + 'var ') + i(s) + ' = ' + r + o
            ),
              t.move(s.start, s.end, e)
          })
        }
        function je(t, e, i, s, r, n, a) {
          var o = this,
            p = s.start,
            h = []
          s.properties.forEach(function (s) {
            var c, l
            if ('Property' === s.type)
              if (((l = s.value), s.computed || 'Identifier' !== s.key.type))
                if (s.computed || 'Literal' !== s.key.type) {
                  var u = t.slice(s.key.start, s.key.end)
                  ;(c = r + '[' + u + ']'), h.push('String(' + u + ')')
                } else
                  (c = r + '[' + s.key.raw + ']'),
                    h.push(JSON.stringify(String(s.key.value)))
              else (c = r + '.' + s.key.name), h.push('"' + s.key.name + '"')
            else {
              if ('RestElement' !== s.type)
                throw new Ie(
                  o,
                  'Unexpected node of type ' + s.type + ' in object pattern'
                )
              ;(l = s.argument),
                (c = e('rest')),
                a.push(function (e, i, a) {
                  var o = s.program.getObjectWithoutPropertiesHelper(t)
                  t.overwrite(
                    s.start,
                    (p = s.argument.start),
                    (n ? i : i + 'var ') +
                      c +
                      ' = ' +
                      o +
                      '( ' +
                      r +
                      ', [' +
                      h.join(', ') +
                      '] )' +
                      a
                  ),
                    t.move(s.start, p, e)
                })
            }
            Te(t, e, i, p, l, c, n, a), (p = s.end)
          }),
            t.remove(p, s.end)
        }
        function Te(t, e, i, s, r, n, a, o) {
          switch (r.type) {
            case 'Identifier':
              t.remove(s, r.start), Oe(t, 0, i, r, n, a, o)
              break
            case 'MemberExpression':
              t.remove(s, r.start),
                (function (t, e, i, s, r, n, a) {
                  a.push(function (e, i, n) {
                    t.prependRight(s.start, i),
                      t.appendLeft(s.end, ' = ' + r + n),
                      t.move(s.start, s.end, e)
                  })
                })(t, 0, 0, r, n, 0, o)
              break
            case 'AssignmentPattern':
              var p,
                h = 'Identifier' === r.left.type
              ;(p = h ? i(r.left) : e(n)),
                o.push(function (e, i, s) {
                  a
                    ? (t.prependRight(
                        r.right.start,
                        p + ' = ' + n + ', ' + p + ' = ' + p + ' === void 0 ? '
                      ),
                      t.appendLeft(r.right.end, ' : ' + p + s))
                    : (t.prependRight(
                        r.right.start,
                        i +
                          'var ' +
                          p +
                          ' = ' +
                          n +
                          '; if ( ' +
                          p +
                          ' === void 0 ) ' +
                          p +
                          ' = '
                      ),
                      t.appendLeft(r.right.end, s)),
                    t.move(r.right.start, r.right.end, e)
                }),
                h
                  ? t.remove(s, r.right.start)
                  : (t.remove(s, r.left.start),
                    t.remove(r.left.end, r.right.start),
                    Te(t, e, i, s, r.left, p, a, o))
              break
            case 'ObjectPattern':
              t.remove(s, (s = r.start))
              var c = n
              r.properties.length > 1 &&
                ((c = e(n)),
                o.push(function (e, i, o) {
                  t.prependRight(r.start, (a ? '' : i + 'var ') + c + ' = '),
                    t.overwrite(r.start, (s = r.start + 1), n),
                    t.appendLeft(s, o),
                    t.overwrite(
                      r.start,
                      (s = r.start + 1),
                      (a ? '' : i + 'var ') + c + ' = ' + n + o
                    ),
                    t.move(r.start, s, e)
                })),
                je(t, e, i, r, c, a, o)
              break
            case 'ArrayPattern':
              if (
                (t.remove(s, (s = r.start)),
                r.elements.filter(Boolean).length > 1)
              ) {
                var l = e(n)
                o.push(function (e, i, o) {
                  t.prependRight(r.start, (a ? '' : i + 'var ') + l + ' = '),
                    t.overwrite(r.start, (s = r.start + 1), n, {
                      contentOnly: !0,
                    }),
                    t.appendLeft(s, o),
                    t.move(r.start, s, e)
                }),
                  r.elements.forEach(function (r, n) {
                    r &&
                      ('RestElement' === r.type
                        ? Te(
                            t,
                            e,
                            i,
                            s,
                            r.argument,
                            l + '.slice(' + n + ')',
                            a,
                            o
                          )
                        : Te(t, e, i, s, r, l + '[' + n + ']', a, o),
                      (s = r.end))
                  })
              } else {
                var u = Le(r.elements, Boolean),
                  d = r.elements[u]
                'RestElement' === d.type
                  ? Te(t, e, i, s, d.argument, n + '.slice(' + u + ')', a, o)
                  : Te(t, e, i, s, d, n + '[' + u + ']', a, o),
                  (s = d.end)
              }
              t.remove(s, r.end)
              break
            default:
              throw new Error(
                'Unexpected node type in destructuring (' + r.type + ')'
              )
          }
        }
        var Re = (function (t) {
          function e() {
            t.apply(this, arguments)
          }
          return (
            t && (e.__proto__ = t),
            ((e.prototype = Object.create(t && t.prototype)).constructor = e),
            (e.prototype.createScope = function () {
              var t = this
              ;(this.parentIsFunction = /Function/.test(this.parent.type)),
                (this.isFunctionBlock =
                  this.parentIsFunction || 'Root' === this.parent.type),
                (this.scope = new Ee({
                  block: !this.isFunctionBlock,
                  parent: this.parent.findScope(!1),
                  declare: function (e) {
                    return t.createdDeclarations.push(e)
                  },
                })),
                this.parentIsFunction &&
                  this.parent.params.forEach(function (e) {
                    t.scope.addDeclaration(e, 'param')
                  })
            }),
            (e.prototype.initialise = function (t) {
              ;(this.thisAlias = null),
                (this.argumentsAlias = null),
                (this.defaultParameters = []),
                (this.createdDeclarations = []),
                this.scope || this.createScope(),
                this.body.forEach(function (e) {
                  return e.initialise(t)
                }),
                this.scope.consolidate()
            }),
            (e.prototype.findLexicalBoundary = function () {
              return 'Program' === this.type ||
                /^Function/.test(this.parent.type)
                ? this
                : this.parent.findLexicalBoundary()
            }),
            (e.prototype.findScope = function (t) {
              return t && !this.isFunctionBlock
                ? this.parent.findScope(t)
                : this.scope
            }),
            (e.prototype.getArgumentsAlias = function () {
              return (
                this.argumentsAlias ||
                  (this.argumentsAlias = this.scope.createIdentifier(
                    'arguments'
                  )),
                this.argumentsAlias
              )
            }),
            (e.prototype.getArgumentsArrayAlias = function () {
              return (
                this.argumentsArrayAlias ||
                  (this.argumentsArrayAlias = this.scope.createIdentifier(
                    'argsArray'
                  )),
                this.argumentsArrayAlias
              )
            }),
            (e.prototype.getThisAlias = function () {
              return (
                this.thisAlias ||
                  (this.thisAlias = this.scope.createIdentifier('this')),
                this.thisAlias
              )
            }),
            (e.prototype.getIndentation = function () {
              if (void 0 === this.indentation) {
                for (
                  var t = this.program.magicString.original,
                    e = this.synthetic || !this.body.length,
                    i = e ? this.start : this.body[0].start;
                  i && '\n' !== t[i];

                )
                  i -= 1
                for (this.indentation = ''; ; ) {
                  var s = t[(i += 1)]
                  if (' ' !== s && '\t' !== s) break
                  this.indentation += s
                }
                for (
                  var r = this.program.magicString.getIndentString(),
                    n = this.parent;
                  n;

                )
                  'constructor' !== n.kind ||
                    n.parent.parent.superClass ||
                    (this.indentation = this.indentation.replace(r, '')),
                    (n = n.parent)
                e && (this.indentation += r)
              }
              return this.indentation
            }),
            (e.prototype.transpile = function (e, i) {
              var s,
                r,
                n = this,
                a = this.getIndentation(),
                o = []
              if (
                (this.argumentsAlias &&
                  o.push(function (t, i, s) {
                    e.appendLeft(
                      t,
                      i + 'var ' + n.argumentsAlias + ' = arguments' + s
                    )
                  }),
                this.thisAlias &&
                  o.push(function (t, i, s) {
                    e.appendLeft(t, i + 'var ' + n.thisAlias + ' = this' + s)
                  }),
                this.argumentsArrayAlias &&
                  o.push(function (t, i, s) {
                    var r = n.scope.createIdentifier('i')
                    e.appendLeft(
                      t,
                      i +
                        'var ' +
                        r +
                        ' = arguments.length, ' +
                        n.argumentsArrayAlias +
                        ' = Array(' +
                        r +
                        ');\n' +
                        a +
                        'while ( ' +
                        r +
                        '-- ) ' +
                        n.argumentsArrayAlias +
                        '[' +
                        r +
                        '] = arguments[' +
                        r +
                        ']' +
                        s
                    )
                  }),
                /Function/.test(this.parent.type)
                  ? this.transpileParameters(this.parent.params, e, i, a, o)
                  : 'CatchClause' === this.parent.type &&
                    this.transpileParameters([this.parent.param], e, i, a, o),
                i.letConst &&
                  this.isFunctionBlock &&
                  this.transpileBlockScopedIdentifiers(e),
                t.prototype.transpile.call(this, e, i),
                this.createdDeclarations.length &&
                  o.push(function (t, i, s) {
                    var r = i + 'var ' + n.createdDeclarations.join(', ') + s
                    e.appendLeft(t, r)
                  }),
                this.synthetic)
              )
                if ('ArrowFunctionExpression' === this.parent.type) {
                  var p = this.body[0]
                  o.length
                    ? (e
                        .appendLeft(this.start, '{')
                        .prependRight(
                          this.end,
                          this.parent.getIndentation() + '}'
                        ),
                      e.prependRight(p.start, '\n' + a + 'return '),
                      e.appendLeft(p.end, ';\n'))
                    : i.arrow &&
                      (e.prependRight(p.start, '{ return '),
                      e.appendLeft(p.end, '; }'))
                } else
                  o.length &&
                    e.prependRight(this.start, '{').appendLeft(this.end, '}')
              s =
                (r = this.body[0]) &&
                'ExpressionStatement' === r.type &&
                'Literal' === r.expression.type &&
                'use strict' === r.expression.value
                  ? this.body[0].end
                  : this.synthetic || 'Root' === this.parent.type
                  ? this.start
                  : this.start + 1
              var h = '\n' + a,
                c = ';'
              o.forEach(function (t, e) {
                e === o.length - 1 && (c = ';\n'), t(s, h, c)
              })
            }),
            (e.prototype.transpileParameters = function (t, e, i, s, r) {
              var n = this
              t.forEach(function (a) {
                if (
                  'AssignmentPattern' === a.type &&
                  'Identifier' === a.left.type
                )
                  i.defaultParameter &&
                    r.push(function (t, i, s) {
                      e.prependRight(
                        a.left.end,
                        i +
                          'if ( ' +
                          a.left.name +
                          ' === void 0 ) ' +
                          a.left.name
                      )
                        .move(a.left.end, a.right.end, t)
                        .appendLeft(a.right.end, s)
                    })
                else if ('RestElement' === a.type)
                  i.spreadRest &&
                    r.push(function (i, r, o) {
                      var p = t[t.length - 2]
                      if (p) e.remove(p ? p.end : a.start, a.end)
                      else {
                        for (
                          var h = a.start, c = a.end;
                          /\s/.test(e.original[h - 1]);

                        )
                          h -= 1
                        for (; /\s/.test(e.original[c]); ) c += 1
                        e.remove(h, c)
                      }
                      var l = a.argument.name,
                        u = n.scope.createIdentifier('len'),
                        d = t.length - 1
                      e.prependRight(
                        i,
                        d
                          ? r +
                              'var ' +
                              l +
                              ' = [], ' +
                              u +
                              ' = arguments.length - ' +
                              d +
                              ';\n' +
                              s +
                              'while ( ' +
                              u +
                              '-- > 0 ) ' +
                              l +
                              '[ ' +
                              u +
                              ' ] = arguments[ ' +
                              u +
                              ' + ' +
                              d +
                              ' ]' +
                              o
                          : r +
                              'var ' +
                              l +
                              ' = [], ' +
                              u +
                              ' = arguments.length;\n' +
                              s +
                              'while ( ' +
                              u +
                              '-- ) ' +
                              l +
                              '[ ' +
                              u +
                              ' ] = arguments[ ' +
                              u +
                              ' ]' +
                              o
                      )
                    })
                else if ('Identifier' !== a.type && i.parameterDestructuring) {
                  var o = n.scope.createIdentifier('ref')
                  Ne(
                    e,
                    function (t) {
                      return n.scope.createIdentifier(t)
                    },
                    function (t) {
                      return n.scope.resolveName(t.name)
                    },
                    a,
                    o,
                    !1,
                    r
                  ),
                    e.prependRight(a.start, o)
                }
              })
            }),
            (e.prototype.transpileBlockScopedIdentifiers = function (t) {
              var e = this
              Object.keys(this.scope.blockScopedDeclarations).forEach(function (
                i
              ) {
                for (
                  var s = 0, r = e.scope.blockScopedDeclarations[i];
                  s < r.length;
                  s += 1
                ) {
                  var n = r[s],
                    a = !1
                  if ('for.let' === n.kind) {
                    var o = n.node.findNearest('ForStatement')
                    if (o.shouldRewriteAsFunction) {
                      var p = e.scope.createIdentifier(i),
                        h = o.reassigned[i] ? e.scope.createIdentifier(i) : i
                      ;(n.name = p),
                        t.overwrite(n.node.start, n.node.end, p, {
                          storeName: !0,
                        }),
                        (o.aliases[i] = { outer: p, inner: h })
                      for (var c = 0, l = n.instances; c < l.length; c += 1) {
                        var u = l[c],
                          d = o.body.contains(u) ? h : p
                        i !== d &&
                          t.overwrite(u.start, u.end, d, { storeName: !0 })
                      }
                      a = !0
                    }
                  }
                  if (!a) {
                    var f = e.scope.createIdentifier(i)
                    if (i !== f) {
                      ;(n.name = f),
                        t.overwrite(n.node.start, n.node.end, f, {
                          storeName: !0,
                        })
                      for (var m = 0, y = n.instances; m < y.length; m += 1) {
                        var g = y[m]
                        ;(g.rewritten = !0),
                          t.overwrite(g.start, g.end, f, { storeName: !0 })
                      }
                    }
                  }
                }
              })
            }),
            e
          )
        })(_e)
        function Ve(t) {
          return 'Identifier' === t.type && 'arguments' === t.name
        }
        function De(t, e, i) {
          for (var s = i.length; s--; ) {
            var r = i[s]
            if (r && 'SpreadElement' === r.type) {
              var n = r.argument
              if ('ArrayExpression' === n.type) {
                var a = n.elements
                if (
                  !a.some(function (t) {
                    return null === t
                  })
                ) {
                  var o = s === i.length - 1
                  0 === a.length
                    ? t.remove(
                        o && 0 !== s ? i[s - 1].end : r.start,
                        o ? e.end - 1 : i[s + 1].start
                      )
                    : (t.remove(r.start, a[0].start),
                      t.remove(a[a.length - 1].end, o ? e.end - 1 : r.end)),
                    i.splice.apply(i, [s, 1].concat(a)),
                    (s += a.length)
                }
              }
            }
          }
        }
        function Be(t) {
          switch (t.type) {
            case 'ArrayExpression':
            case 'CallExpression':
            case 'Identifier':
            case 'ParenthesizedExpression':
            case 'ThisExpression':
              return !1
            default:
              return !0
          }
        }
        function Fe(t, e, i, s, r) {
          for (var n = e.length, a = -1; n--; ) {
            var o = e[n]
            o &&
              'SpreadElement' === o.type &&
              (Ve(o.argument) &&
                t.overwrite(o.argument.start, o.argument.end, s),
              (a = n))
          }
          if (-1 === a) return !1
          if (r) {
            for (n = 0; n < e.length; n += 1) {
              var p = e[n]
              'SpreadElement' === p.type
                ? t.remove(p.start, p.argument.start)
                : (t.prependRight(p.start, '['), t.prependRight(p.end, ']'))
            }
            return !0
          }
          var h = e[a],
            c = e[a - 1]
          if (c) t.overwrite(c.end, h.start, ' ].concat( ')
          else {
            var l
            if (i !== h.start)
              (l = Be(h.argument))
                ? t.overwrite(i, h.start, '( ')
                : t.remove(i, h.start)
            else {
              if ('CallExpression' !== h.parent.type)
                throw new Ie(
                  'Unsupported spread construct, please raise an issue at https://github.com/bublejs/buble/issues',
                  h
                )
              l = Be(h.argument)
            }
            t.overwrite(h.end, e[1].start, l ? ' ).concat( ' : '.concat( ')
          }
          for (n = a; n < e.length; n += 1)
            (h = e[n]) &&
              ('SpreadElement' === h.type
                ? t.remove(h.start, h.argument.start)
                : (t.appendLeft(h.start, '['), t.appendLeft(h.end, ']')))
          return !0
        }
        var Me = (function (t) {
          function e() {
            t.apply(this, arguments)
          }
          return (
            t && (e.__proto__ = t),
            ((e.prototype = Object.create(t && t.prototype)).constructor = e),
            (e.prototype.initialise = function (e) {
              if (e.spreadRest && this.elements.length)
                for (
                  var i = this.findLexicalBoundary(), s = this.elements.length;
                  s--;

                ) {
                  var r = this.elements[s]
                  r &&
                    'SpreadElement' === r.type &&
                    Ve(r.argument) &&
                    (this.argumentsArrayAlias = i.getArgumentsArrayAlias())
                }
              t.prototype.initialise.call(this, e)
            }),
            (e.prototype.transpile = function (e, i) {
              if ((t.prototype.transpile.call(this, e, i), i.spreadRest)) {
                if ((De(e, this, this.elements), this.elements.length)) {
                  var s = this.elements[this.elements.length - 1]
                  s &&
                    /\s*,/.test(e.original.slice(s.end, this.end)) &&
                    e.overwrite(s.end, this.end - 1, ' ')
                }
                if (1 === this.elements.length) {
                  var r = this.elements[0]
                  r &&
                    'SpreadElement' === r.type &&
                    (Ve(r.argument)
                      ? e.overwrite(
                          this.start,
                          this.end,
                          '[].concat( ' + this.argumentsArrayAlias + ' )'
                        )
                      : (e.overwrite(
                          this.start,
                          r.argument.start,
                          '[].concat( '
                        ),
                        e.overwrite(r.end, this.end, ' )')))
                } else
                  Fe(e, this.elements, this.start, this.argumentsArrayAlias) &&
                    e.overwrite(this.end - 1, this.end, ')')
              }
            }),
            e
          )
        })(_e)
        function Ue(t, e) {
          for (; ')' !== t.original[e]; ) {
            if (',' === t.original[e]) return void t.remove(e, e + 1)
            '/' === t.original[e] &&
              (e =
                '/' === t.original[e + 1]
                  ? t.original.indexOf('\n', e)
                  : t.original.indexOf('*/', e) + 1),
              (e += 1)
          }
        }
        var qe = (function (t) {
          function e() {
            t.apply(this, arguments)
          }
          return (
            t && (e.__proto__ = t),
            ((e.prototype = Object.create(t && t.prototype)).constructor = e),
            (e.prototype.initialise = function (e) {
              this.async &&
                e.asyncAwait &&
                Ie.missingTransform(
                  'async arrow functions',
                  'asyncAwait',
                  this
                ),
                this.body.createScope(),
                t.prototype.initialise.call(this, e)
            }),
            (e.prototype.transpile = function (e, i) {
              for (
                var s = this.start, r = (this.body || this.params[0]).start - 1;
                '(' !== e.original[s] && s < r;

              )
                ++s
              '(' !== e.original[s] && (s = -1)
              var n = -1 === s
              if (i.arrow || this.needsArguments(i)) {
                for (var a = this.body.start; '=' !== e.original[a]; ) a -= 1
                e.remove(a, this.body.start),
                  t.prototype.transpile.call(this, e, i),
                  n &&
                    (e.prependRight(this.params[0].start, '('),
                    e.appendLeft(this.params[0].end, ')'))
                var o,
                  p = this.parent && 'ExpressionStatement' === this.parent.type,
                  h = p ? '!' : ''
                this.async && (h += 'async '),
                  (h += 'function'),
                  p || (h += ' '),
                  (o = n ? this.params[0].start : s) > this.start
                    ? e.overwrite(this.start, o, h)
                    : e.prependRight(this.start, h)
              } else t.prototype.transpile.call(this, e, i)
              i.trailingFunctionCommas &&
                this.params.length &&
                !n &&
                Ue(e, this.params[this.params.length - 1].end)
            }),
            (e.prototype.needsArguments = function (t) {
              return (
                t.spreadRest &&
                this.params.filter(function (t) {
                  return 'RestElement' === t.type
                }).length > 0
              )
            }),
            e
          )
        })(_e)
        function Je(t, e) {
          var i = e.findDeclaration(t.name)
          if (i && 'const' === i.kind) throw new Ie(t.name + ' is read-only', t)
        }
        var Xe = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                if ('Identifier' === this.left.type) {
                  var i = this.findScope(!1).findDeclaration(this.left.name),
                    s = i && i.node.ancestor(3)
                  s &&
                    'ForStatement' === s.type &&
                    s.body.contains(this) &&
                    (s.reassigned[this.left.name] = !0)
                }
                t.prototype.initialise.call(this, e)
              }),
              (e.prototype.transpile = function (e, i) {
                'Identifier' === this.left.type &&
                  Je(this.left, this.findScope(!1)),
                  '**=' === this.operator && i.exponentiation
                    ? this.transpileExponentiation(e, i)
                    : /Pattern/.test(this.left.type) &&
                      i.destructuring &&
                      this.transpileDestructuring(e),
                  t.prototype.transpile.call(this, e, i)
              }),
              (e.prototype.transpileDestructuring = function (t) {
                var e = this,
                  i = this.findScope(!0),
                  s = this.findScope(!1),
                  r = i.createDeclaration('assign')
                t.appendRight(this.left.end, '(' + r),
                  t.appendLeft(this.right.end, ', ')
                var n = []
                Ne(
                  t,
                  function (t) {
                    return i.createDeclaration(t)
                  },
                  function (t) {
                    var e = s.resolveName(t.name)
                    return Je(t, s), e
                  },
                  this.left,
                  r,
                  !0,
                  n
                )
                var a = ', '
                n.forEach(function (t, i) {
                  i === n.length - 1 && (a = ''), t(e.end, '', a)
                }),
                  'ExpressionStatement' === this.unparenthesizedParent().type
                    ? t.prependRight(this.end, ')')
                    : t.appendRight(this.end, ', ' + r + ')')
              }),
              (e.prototype.transpileExponentiation = function (t) {
                for (
                  var e, i = this.findScope(!1), s = this.left.end;
                  '*' !== t.original[s];

                )
                  s += 1
                t.remove(s, s + 2)
                var r = this.left.unparenthesize()
                if ('Identifier' === r.type) e = i.resolveName(r.name)
                else if ('MemberExpression' === r.type) {
                  var n,
                    a,
                    o = !1,
                    p = !1,
                    h = this.findNearest(/(?:Statement|Declaration)$/),
                    c = h.getIndentation()
                  'Identifier' === r.property.type
                    ? (a = r.computed
                        ? i.resolveName(r.property.name)
                        : r.property.name)
                    : ((a = i.createDeclaration('property')), (p = !0)),
                    'Identifier' === r.object.type
                      ? (n = i.resolveName(r.object.name))
                      : ((n = i.createDeclaration('object')), (o = !0)),
                    r.start === h.start
                      ? o && p
                        ? (t.prependRight(h.start, n + ' = '),
                          t.overwrite(
                            r.object.end,
                            r.property.start,
                            ';\n' + c + a + ' = '
                          ),
                          t.overwrite(
                            r.property.end,
                            r.end,
                            ';\n' + c + n + '[' + a + ']'
                          ))
                        : o
                        ? (t.prependRight(h.start, n + ' = '),
                          t.appendLeft(r.object.end, ';\n' + c),
                          t.appendLeft(r.object.end, n))
                        : p &&
                          (t.prependRight(r.property.start, a + ' = '),
                          t.appendLeft(r.property.end, ';\n' + c),
                          t.move(r.property.start, r.property.end, this.start),
                          t.appendLeft(r.object.end, '[' + a + ']'),
                          t.remove(r.object.end, r.property.start),
                          t.remove(r.property.end, r.end))
                      : (o && p
                          ? (t.prependRight(r.start, '( ' + n + ' = '),
                            t.overwrite(
                              r.object.end,
                              r.property.start,
                              ', ' + a + ' = '
                            ),
                            t.overwrite(
                              r.property.end,
                              r.end,
                              ', ' + n + '[' + a + ']'
                            ))
                          : o
                          ? (t.prependRight(r.start, '( ' + n + ' = '),
                            t.appendLeft(r.object.end, ', ' + n))
                          : p &&
                            (t.prependRight(r.property.start, '( ' + a + ' = '),
                            t.appendLeft(r.property.end, ', '),
                            t.move(r.property.start, r.property.end, r.start),
                            t.overwrite(
                              r.object.end,
                              r.property.start,
                              '[' + a + ']'
                            ),
                            t.remove(r.property.end, r.end)),
                        p && t.appendLeft(this.end, ' )')),
                    (e = n + (r.computed || p ? '[' + a + ']' : '.' + a))
                }
                t.prependRight(this.right.start, 'Math.pow( ' + e + ', '),
                  t.appendLeft(this.right.end, ' )')
              }),
              e
            )
          })(_e),
          ze = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                e.asyncAwait &&
                  Ie.missingTransform('await', 'asyncAwait', this),
                  t.prototype.initialise.call(this, e)
              }),
              e
            )
          })(_e),
          We = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.transpile = function (e, i) {
                '**' === this.operator &&
                  i.exponentiation &&
                  (e.prependRight(this.start, 'Math.pow( '),
                  e.overwrite(this.left.end, this.right.start, ', '),
                  e.appendLeft(this.end, ' )')),
                  t.prototype.transpile.call(this, e, i)
              }),
              e
            )
          })(_e),
          He = /(?:For(?:In|Of)?|While)Statement/,
          Ge = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function () {
                var t = this.findNearest(He),
                  e = this.findNearest('SwitchCase')
                t &&
                  (!e || t.depth > e.depth) &&
                  ((t.canBreak = !0), (this.loop = t))
              }),
              (e.prototype.transpile = function (t) {
                if (this.loop && this.loop.shouldRewriteAsFunction) {
                  if (this.label)
                    throw new Ie(
                      'Labels are not currently supported in a loop with locally-scoped variables',
                      this
                    )
                  t.overwrite(this.start, this.start + 5, "return 'break'")
                }
              }),
              e
            )
          })(_e),
          Qe = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                if (e.spreadRest && this.arguments.length > 1)
                  for (
                    var i = this.findLexicalBoundary(),
                      s = this.arguments.length;
                    s--;

                  ) {
                    var r = this.arguments[s]
                    'SpreadElement' === r.type &&
                      Ve(r.argument) &&
                      (this.argumentsArrayAlias = i.getArgumentsArrayAlias())
                  }
                t.prototype.initialise.call(this, e)
              }),
              (e.prototype.transpile = function (e, i) {
                if (
                  (i.spreadRest &&
                    this.arguments.length &&
                    De(e, this, this.arguments),
                  i.spreadRest && this.arguments.length)
                ) {
                  var s,
                    r = !1,
                    n = this.arguments[0]
                  if (
                    (1 === this.arguments.length
                      ? 'SpreadElement' === n.type &&
                        (e.remove(n.start, n.argument.start), (r = !0))
                      : (r = Fe(
                          e,
                          this.arguments,
                          n.start,
                          this.argumentsArrayAlias
                        )),
                    r)
                  ) {
                    var a = null
                    if (
                      ('Super' === this.callee.type
                        ? (a = this.callee)
                        : 'MemberExpression' === this.callee.type &&
                          'Super' === this.callee.object.type &&
                          (a = this.callee.object),
                      a || 'MemberExpression' !== this.callee.type)
                    )
                      s = 'void 0'
                    else if ('Identifier' === this.callee.object.type)
                      s = this.callee.object.name
                    else {
                      s = this.findScope(!0).createDeclaration('ref')
                      var o = this.callee.object
                      e.prependRight(o.start, '(' + s + ' = '),
                        e.appendLeft(o.end, ')')
                    }
                    e.appendLeft(this.callee.end, '.apply'),
                      a
                        ? ((a.noCall = !0),
                          this.arguments.length > 1 &&
                            ('SpreadElement' === n.type
                              ? Be(n.argument) && e.prependRight(n.start, '( ')
                              : e.prependRight(n.start, '[ '),
                            e.appendLeft(
                              this.arguments[this.arguments.length - 1].end,
                              ' )'
                            )))
                        : 1 === this.arguments.length
                        ? e.prependRight(n.start, s + ', ')
                        : ('SpreadElement' === n.type
                            ? Be(n.argument)
                              ? e.appendLeft(n.start, s + ', ( ')
                              : e.appendLeft(n.start, s + ', ')
                            : e.appendLeft(n.start, s + ', [ '),
                          e.appendLeft(
                            this.arguments[this.arguments.length - 1].end,
                            ' )'
                          ))
                  }
                }
                i.trailingFunctionCommas &&
                  this.arguments.length &&
                  Ue(e, this.arguments[this.arguments.length - 1].end),
                  t.prototype.transpile.call(this, e, i)
              }),
              e
            )
          })(_e),
          Ke = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.transpile = function (e, i, s, r) {
                var n = this
                if (i.classes) {
                  var a = this.parent.name,
                    o = e.getIndentString(),
                    p = this.getIndentation() + (s ? o : ''),
                    h = p + o,
                    c = Le(this.body, function (t) {
                      return 'constructor' === t.kind
                    }),
                    l = this.body[c],
                    u = '',
                    d = ''
                  if (
                    (this.body.length
                      ? (e.remove(this.start, this.body[0].start),
                        e.remove(this.body[this.body.length - 1].end, this.end))
                      : e.remove(this.start, this.end),
                    l)
                  ) {
                    l.value.body.isConstructorBody = !0
                    var f = this.body[c + 1]
                    c > 0 &&
                      (e.remove(this.body[c - 1].end, l.start),
                      e.move(
                        l.start,
                        f ? f.start : this.end - 1,
                        this.body[0].start
                      )),
                      s || e.appendLeft(l.end, ';')
                  }
                  var m = []
                  this.body.forEach(function (t) {
                    if (
                      'FieldDefinition' === t.type &&
                      (m.push(
                        t.computed
                          ? 'this' + e.slice(t.start, t.end) + ';'
                          : 'this.' + e.slice(t.start, t.end) + ';'
                      ),
                      e.remove(t.start, t.end),
                      '' !== e.byStart[t.end].content)
                    ) {
                      for (
                        var i = 0;
                        i < e.byStart[t.end].content.length &&
                        -1 ===
                          e.byStart[t.end].content.slice(0, i).indexOf(';');
                        i++
                      );
                      i > 0 && e.remove(t.end, t.end + i)
                    }
                  })
                  var y = !1 !== this.program.options.namedFunctionExpressions,
                    g =
                      y ||
                      this.parent.superClass ||
                      'ClassDeclaration' !== this.parent.type
                  if (this.parent.superClass) {
                    var v =
                      'if ( ' +
                      r +
                      ' ) ' +
                      a +
                      '.__proto__ = ' +
                      r +
                      ';\n' +
                      p +
                      a +
                      '.prototype = Object.create( ' +
                      r +
                      ' && ' +
                      r +
                      '.prototype );\n' +
                      p +
                      a +
                      '.prototype.constructor = ' +
                      a +
                      ';'
                    u += l
                      ? '\n\n' + p + v
                      : (v =
                          'function ' +
                          a +
                          ' () {' +
                          (m.length
                            ? '\n' + h + m.join('\n' + h) + '\n' + h
                            : '') +
                          (r
                            ? '\n' +
                              h +
                              r +
                              '.apply(this, arguments);\n' +
                              p +
                              '}'
                            : '}') +
                          (s ? '' : ';') +
                          (this.body.length ? '\n\n' + p : '') +
                          v) +
                        '\n\n' +
                        p
                  } else if (!l) {
                    var x =
                      'function ' +
                      (g ? a + ' ' : '') +
                      '() {' +
                      (m.length ? '\n' + h + m.join('\n' + h) + '\n' + p : '') +
                      '}'
                    'ClassDeclaration' === this.parent.type && (x += ';'),
                      this.body.length && (x += '\n\n' + p),
                      (u += x)
                  }
                  l &&
                    m.length &&
                    e.appendLeft(
                      l.value.body.start + 1,
                      '\n' + h + m.join('\n' + h)
                    )
                  var b,
                    _,
                    k = this.findScope(!1),
                    S = [],
                    w = []
                  if (
                    (this.body.forEach(function (t, s) {
                      if (
                        (('get' !== t.kind && 'set' !== t.kind) ||
                          !i.getterSetter ||
                          Ie.missingTransform(
                            'getters and setters',
                            'getterSetter',
                            t
                          ),
                        'FieldDefinition' !== t.type)
                      )
                        if ('constructor' !== t.kind) {
                          t.static &&
                            e.remove(
                              t.start,
                              t.start + (' ' == e.original[t.start + 6] ? 7 : 6)
                            )
                          var r,
                            o = 'method' !== t.kind,
                            h = t.key.name
                          ;(we[h] || t.value.body.scope.references[h]) &&
                            (h = k.createIdentifier(h))
                          var l = !1
                          if (
                            (t.computed ||
                              'Literal' !== t.key.type ||
                              ((l = !0), (t.computed = !0)),
                            o)
                          ) {
                            if (t.computed)
                              throw new Error(
                                'Computed accessor properties are not currently supported'
                              )
                            e.remove(t.start, t.key.start),
                              t.static
                                ? (~w.indexOf(t.key.name) || w.push(t.key.name),
                                  _ ||
                                    (_ = k.createIdentifier('staticAccessors')),
                                  (r = '' + _))
                                : (~S.indexOf(t.key.name) || S.push(t.key.name),
                                  b ||
                                    (b = k.createIdentifier(
                                      'prototypeAccessors'
                                    )),
                                  (r = '' + b))
                          } else r = t.static ? '' + a : a + '.prototype'
                          t.computed || (r += '.'),
                            ((c > 0 && s === c + 1) ||
                              (0 === s && c === n.body.length - 1)) &&
                              (r = '\n\n' + p + r)
                          var u = t.key.end
                          if (t.computed)
                            if (l)
                              e.prependRight(t.key.start, '['),
                                e.appendLeft(t.key.end, ']')
                            else {
                              for (; ']' !== e.original[u]; ) u += 1
                              u += 1
                            }
                          var d =
                            (o ? '.' + t.kind : '') +
                            ' = ' +
                            (t.value.async ? 'async ' : '') +
                            'function' +
                            (t.value.generator ? '* ' : ' ') +
                            (t.computed || o || !y ? '' : h + ' ')
                          e.remove(u, t.value.start),
                            e.prependRight(t.value.start, d),
                            e.appendLeft(t.end, ';'),
                            t.value.generator && e.remove(t.start, t.key.start)
                          var f = t.key.start
                          if (t.computed && !l)
                            for (; '[' != e.original[f]; ) --f
                          t.start < f
                            ? e.overwrite(t.start, f, r)
                            : e.prependRight(t.start, r)
                        } else
                          e.overwrite(
                            t.key.start,
                            t.key.end,
                            'function' + (g ? ' ' + a : '')
                          )
                    }),
                    S.length || w.length)
                  ) {
                    var E = [],
                      C = []
                    S.length &&
                      (E.push(
                        'var ' +
                          b +
                          ' = { ' +
                          S.map(function (t) {
                            return t + ': { configurable: true }'
                          }).join(',') +
                          ' };'
                      ),
                      C.push(
                        'Object.defineProperties( ' +
                          a +
                          '.prototype, ' +
                          b +
                          ' );'
                      )),
                      w.length &&
                        (E.push(
                          'var ' +
                            _ +
                            ' = { ' +
                            w
                              .map(function (t) {
                                return t + ': { configurable: true }'
                              })
                              .join(',') +
                            ' };'
                        ),
                        C.push(
                          'Object.defineProperties( ' + a + ', ' + _ + ' );'
                        )),
                      l && (u += '\n\n' + p),
                      (u += E.join('\n' + p)),
                      l || (u += '\n\n' + p),
                      (d += '\n\n' + p + C.join('\n' + p))
                  }
                  l ? e.appendLeft(l.end, u) : e.prependRight(this.start, u),
                    e.appendLeft(this.end, d)
                }
                t.prototype.transpile.call(this, e, i)
              }),
              e
            )
          })(_e),
          $e = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                this.id
                  ? ((this.name = this.id.name),
                    this.findScope(!0).addDeclaration(this.id, 'class'))
                  : (this.name = this.findScope(!0).createIdentifier(
                      'defaultExport'
                    )),
                  t.prototype.initialise.call(this, e)
              }),
              (e.prototype.transpile = function (t, e) {
                if (e.classes) {
                  this.superClass ||
                    (function (t, e) {
                      var i = t.start,
                        s = t.end,
                        r = e.getIndentString(),
                        n = r.length,
                        a = i - n
                      t.program.indentExclusions[a] ||
                        e.original.slice(a, i) !== r ||
                        e.remove(a, i)
                      for (
                        var o,
                          p = new RegExp(r + '\\S', 'g'),
                          h = e.original.slice(i, s);
                        (o = p.exec(h));

                      ) {
                        var c = i + o.index
                        t.program.indentExclusions[c] || e.remove(c, c + n)
                      }
                    })(this.body, t)
                  var i =
                      this.superClass && (this.superClass.name || 'superclass'),
                    s = this.getIndentation(),
                    r = s + t.getIndentString(),
                    n = 'ExportDefaultDeclaration' === this.parent.type
                  n && t.remove(this.parent.start, this.start)
                  var a = this.start
                  this.id
                    ? (t.overwrite(a, this.id.start, 'var '), (a = this.id.end))
                    : t.prependLeft(a, 'var ' + this.name),
                    this.superClass
                      ? this.superClass.end === this.body.start
                        ? (t.remove(a, this.superClass.start),
                          t.appendLeft(
                            a,
                            ' = /*@__PURE__*/(function (' + i + ') {\n' + r
                          ))
                        : (t.overwrite(a, this.superClass.start, ' = '),
                          t.overwrite(
                            this.superClass.end,
                            this.body.start,
                            '/*@__PURE__*/(function (' + i + ') {\n' + r
                          ))
                      : a === this.body.start
                      ? t.appendLeft(a, ' = ')
                      : t.overwrite(a, this.body.start, ' = '),
                    this.body.transpile(t, e, !!this.superClass, i)
                  var o = n
                    ? '\n\n' + s + 'export default ' + this.name + ';'
                    : ''
                  this.superClass
                    ? (t.appendLeft(
                        this.end,
                        '\n\n' + r + 'return ' + this.name + ';\n' + s + '}('
                      ),
                      t.move(
                        this.superClass.start,
                        this.superClass.end,
                        this.end
                      ),
                      t.prependRight(this.end, '));' + o))
                    : o && t.prependRight(this.end, o)
                } else this.body.transpile(t, e, !1, null)
              }),
              e
            )
          })(_e),
          Ze = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                ;(this.name =
                  (this.id
                    ? this.id.name
                    : 'VariableDeclarator' === this.parent.type
                    ? this.parent.id.name
                    : 'AssignmentExpression' !== this.parent.type
                    ? null
                    : 'Identifier' === this.parent.left.type
                    ? this.parent.left.name
                    : 'MemberExpression' === this.parent.left.type
                    ? this.parent.left.property.name
                    : null) ||
                  this.findScope(!0).createIdentifier('anonymous')),
                  t.prototype.initialise.call(this, e)
              }),
              (e.prototype.transpile = function (t, e) {
                if (e.classes) {
                  var i =
                      this.superClass && (this.superClass.name || 'superclass'),
                    s = this.getIndentation(),
                    r = s + t.getIndentString()
                  this.superClass
                    ? (t.remove(this.start, this.superClass.start),
                      t.remove(this.superClass.end, this.body.start),
                      t.appendRight(
                        this.start,
                        '/*@__PURE__*/(function (' + i + ') {\n' + r
                      ))
                    : t.overwrite(
                        this.start,
                        this.body.start,
                        '/*@__PURE__*/(function () {\n' + r
                      ),
                    this.body.transpile(t, e, !0, i)
                  var n = ''
                  this.superClass &&
                    ((n = t.slice(this.superClass.start, this.superClass.end)),
                    t.remove(this.superClass.start, this.superClass.end)),
                    t.appendLeft(
                      this.end,
                      '\n\n' +
                        r +
                        'return ' +
                        this.name +
                        ';\n' +
                        s +
                        '}(' +
                        n +
                        '))'
                    )
                } else this.body.transpile(t, e, !1)
              }),
              e
            )
          })(_e),
          Ye = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.transpile = function (t) {
                if (this.findNearest(He).shouldRewriteAsFunction) {
                  if (this.label)
                    throw new Ie(
                      'Labels are not currently supported in a loop with locally-scoped variables',
                      this
                    )
                  t.overwrite(this.start, this.start + 8, 'return')
                }
              }),
              e
            )
          })(_e),
          ti = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                e.moduleExport &&
                  Ie.missingTransform('export', 'moduleExport', this),
                  t.prototype.initialise.call(this, e)
              }),
              e
            )
          })(_e),
          ei = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                e.moduleExport &&
                  Ie.missingTransform('export', 'moduleExport', this),
                  t.prototype.initialise.call(this, e)
              }),
              e
            )
          })(_e),
          ii = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.findScope = function (t) {
                return t || !this.createdScope
                  ? this.parent.findScope(t)
                  : this.body.scope
              }),
              (e.prototype.initialise = function (e) {
                if (
                  (this.body.createScope(),
                  (this.createdScope = !0),
                  (this.reassigned = Object.create(null)),
                  (this.aliases = Object.create(null)),
                  (this.thisRefs = []),
                  t.prototype.initialise.call(this, e),
                  e.letConst)
                )
                  for (
                    var i = Object.keys(this.body.scope.declarations),
                      s = i.length;
                    s--;

                  ) {
                    for (
                      var r = this.body.scope.declarations[i[s]],
                        n = r.instances.length;
                      n--;

                    ) {
                      var a = r.instances[n].findNearest(/Function/)
                      if (a && a.depth > this.depth) {
                        this.shouldRewriteAsFunction = !0
                        for (
                          var o = 0, p = this.thisRefs;
                          o < p.length;
                          o += 1
                        ) {
                          var h = p[o]
                          h.alias =
                            h.alias || h.findLexicalBoundary().getThisAlias()
                        }
                        break
                      }
                    }
                    if (this.shouldRewriteAsFunction) break
                  }
              }),
              (e.prototype.transpile = function (e, i) {
                var s =
                  'ForOfStatement' != this.type &&
                  ('BlockStatement' !== this.body.type ||
                    ('BlockStatement' === this.body.type &&
                      this.body.synthetic))
                if (this.shouldRewriteAsFunction) {
                  var r = this.getIndentation(),
                    n = r + e.getIndentString(),
                    a = this.args ? ' ' + this.args.join(', ') + ' ' : '',
                    o = this.params ? ' ' + this.params.join(', ') + ' ' : '',
                    p = this.findScope(!0),
                    h = p.createIdentifier('loop'),
                    c =
                      'var ' +
                      h +
                      ' = function (' +
                      o +
                      ') ' +
                      (this.body.synthetic
                        ? '{\n' + r + e.getIndentString()
                        : ''),
                    l =
                      (this.body.synthetic ? '\n' + r + '}' : '') + ';\n\n' + r
                  if (
                    (e.prependRight(this.body.start, c),
                    e.appendLeft(this.body.end, l),
                    e.move(this.start, this.body.start, this.body.end),
                    this.canBreak || this.canReturn)
                  ) {
                    var u = p.createIdentifier('returned'),
                      d = '{\n' + n + 'var ' + u + ' = ' + h + '(' + a + ');\n'
                    this.canBreak &&
                      (d += '\n' + n + 'if ( ' + u + " === 'break' ) break;"),
                      this.canReturn &&
                        (d +=
                          '\n' + n + 'if ( ' + u + ' ) return ' + u + '.v;'),
                      e.prependRight(this.body.end, (d += '\n' + r + '}'))
                  } else {
                    var f = h + '(' + a + ');'
                    'DoWhileStatement' === this.type
                      ? e.overwrite(
                          this.start,
                          this.body.start,
                          'do {\n' + n + f + '\n' + r + '}'
                        )
                      : e.prependRight(this.body.end, f)
                  }
                } else
                  s &&
                    (e.appendLeft(this.body.start, '{ '),
                    e.prependRight(this.body.end, ' }'))
                t.prototype.transpile.call(this, e, i)
              }),
              e
            )
          })(_e),
          si = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.findScope = function (t) {
                return t || !this.createdScope
                  ? this.parent.findScope(t)
                  : this.body.scope
              }),
              (e.prototype.transpile = function (e, i) {
                var s = this,
                  r = this.getIndentation() + e.getIndentString()
                if (this.shouldRewriteAsFunction) {
                  var n =
                      'VariableDeclaration' === this.init.type
                        ? this.init.declarations.map(function (t) {
                            return ke(t.id)
                          })
                        : [],
                    a = this.aliases
                  ;(this.args = n.map(function (t) {
                    return t in s.aliases ? s.aliases[t].outer : t
                  })),
                    (this.params = n.map(function (t) {
                      return t in s.aliases ? s.aliases[t].inner : t
                    }))
                  var o = Object.keys(this.reassigned).map(function (t) {
                    return a[t].outer + ' = ' + a[t].inner + ';'
                  })
                  o.length &&
                    (this.body.synthetic
                      ? e.appendLeft(this.body.body[0].end, '; ' + o.join(' '))
                      : e.appendLeft(
                          this.body.body[this.body.body.length - 1].end,
                          '\n\n' + r + o.join('\n' + r)
                        ))
                }
                t.prototype.transpile.call(this, e, i)
              }),
              e
            )
          })(ii),
          ri = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.findScope = function (t) {
                return t || !this.createdScope
                  ? this.parent.findScope(t)
                  : this.body.scope
              }),
              (e.prototype.transpile = function (e, i) {
                var s = this,
                  r = 'VariableDeclaration' === this.left.type
                if (this.shouldRewriteAsFunction) {
                  var n = r
                    ? this.left.declarations.map(function (t) {
                        return ke(t.id)
                      })
                    : []
                  ;(this.args = n.map(function (t) {
                    return t in s.aliases ? s.aliases[t].outer : t
                  })),
                    (this.params = n.map(function (t) {
                      return t in s.aliases ? s.aliases[t].inner : t
                    }))
                }
                t.prototype.transpile.call(this, e, i)
                var a = r ? this.left.declarations[0].id : this.left
                'Identifier' !== a.type && this.destructurePattern(e, a, r)
              }),
              (e.prototype.destructurePattern = function (t, e, i) {
                var s = this.findScope(!0),
                  r = this.getIndentation() + t.getIndentString(),
                  n = s.createIdentifier('ref'),
                  a = this.body.body.length
                    ? this.body.body[0].start
                    : this.body.start + 1
                t.move(e.start, e.end, a),
                  t.prependRight(e.end, i ? n : 'var ' + n)
                var o = []
                Ne(
                  t,
                  function (t) {
                    return s.createIdentifier(t)
                  },
                  function (t) {
                    return s.resolveName(t.name)
                  },
                  e,
                  n,
                  !1,
                  o
                )
                var p = ';\n' + r
                o.forEach(function (t, e) {
                  e === o.length - 1 && (p = ';\n\n' + r), t(a, '', p)
                })
              }),
              e
            )
          })(ii),
          ni = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                e.forOf &&
                  !e.dangerousForOf &&
                  Ie.missingTransform(
                    'for-of statements',
                    'forOf',
                    this,
                    'dangerousForOf'
                  ),
                  this.await &&
                    e.asyncAwait &&
                    Ie.missingTransform(
                      'for-await-of statements',
                      'asyncAwait',
                      this
                    ),
                  t.prototype.initialise.call(this, e)
              }),
              (e.prototype.transpile = function (e, i) {
                if ((t.prototype.transpile.call(this, e, i), i.dangerousForOf))
                  if (this.body.body[0]) {
                    var s = this.findScope(!0),
                      r = this.getIndentation(),
                      n = r + e.getIndentString(),
                      a = s.createIdentifier('i'),
                      o = s.createIdentifier('list')
                    this.body.synthetic &&
                      (e.prependRight(this.left.start, '{\n' + n),
                      e.appendLeft(this.body.body[0].end, '\n' + r + '}'))
                    var p = this.body.body[0].start
                    e.remove(this.left.end, this.right.start),
                      e.move(this.left.start, this.left.end, p),
                      e.prependRight(
                        this.right.start,
                        'var ' + a + ' = 0, ' + o + ' = '
                      ),
                      e.appendLeft(
                        this.right.end,
                        '; ' + a + ' < ' + o + '.length; ' + a + ' += 1'
                      )
                    var h = 'VariableDeclaration' === this.left.type,
                      c = h ? this.left.declarations[0].id : this.left
                    if ('Identifier' !== c.type) {
                      var l = [],
                        u = s.createIdentifier('ref')
                      Ne(
                        e,
                        function (t) {
                          return s.createIdentifier(t)
                        },
                        function (t) {
                          return s.resolveName(t.name)
                        },
                        c,
                        u,
                        !h,
                        l
                      )
                      var d = ';\n' + n
                      l.forEach(function (t, e) {
                        e === l.length - 1 && (d = ';\n\n' + n), t(p, '', d)
                      }),
                        h
                          ? (e.appendLeft(
                              this.left.start + this.left.kind.length + 1,
                              u
                            ),
                            e.appendLeft(
                              this.left.end,
                              ' = ' + o + '[' + a + '];\n' + n
                            ))
                          : e.appendLeft(
                              this.left.end,
                              'var ' + u + ' = ' + o + '[' + a + '];\n' + n
                            )
                    } else
                      e.appendLeft(
                        this.left.end,
                        ' = ' + o + '[' + a + '];\n\n' + n
                      )
                  } else
                    'VariableDeclaration' === this.left.type &&
                    'var' === this.left.kind
                      ? (e.remove(this.start, this.left.start),
                        e.appendLeft(this.left.end, ';'),
                        e.remove(this.left.end, this.end))
                      : e.remove(this.start, this.end)
              }),
              e
            )
          })(ii),
          ai = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                this.generator &&
                  e.generator &&
                  Ie.missingTransform('generators', 'generator', this),
                  this.async &&
                    e.asyncAwait &&
                    Ie.missingTransform('async functions', 'asyncAwait', this),
                  this.body.createScope(),
                  this.id &&
                    this.findScope(!0).addDeclaration(this.id, 'function'),
                  t.prototype.initialise.call(this, e)
              }),
              (e.prototype.transpile = function (e, i) {
                t.prototype.transpile.call(this, e, i),
                  i.trailingFunctionCommas &&
                    this.params.length &&
                    Ue(e, this.params[this.params.length - 1].end)
              }),
              e
            )
          })(_e),
          oi = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                this.generator &&
                  e.generator &&
                  Ie.missingTransform('generators', 'generator', this),
                  this.async &&
                    e.asyncAwait &&
                    Ie.missingTransform('async functions', 'asyncAwait', this),
                  this.body.createScope(),
                  this.id &&
                    this.body.scope.addDeclaration(this.id, 'function'),
                  t.prototype.initialise.call(this, e)
                var i,
                  s = this.parent
                if (
                  ((e.conciseMethodProperty &&
                    'Property' === s.type &&
                    'init' === s.kind &&
                    s.method &&
                    'Identifier' === s.key.type) ||
                  (e.classes &&
                    'MethodDefinition' === s.type &&
                    'method' === s.kind &&
                    'Identifier' === s.key.type)
                    ? (i = s.key.name)
                    : this.id &&
                      'Identifier' === this.id.type &&
                      (i = this.id.alias || this.id.name),
                  i)
                )
                  for (var r = 0, n = this.params; r < n.length; r += 1) {
                    var a = n[r]
                    if ('Identifier' === a.type && i === a.name) {
                      var o = this.body.scope,
                        p = o.declarations[i],
                        h = o.createIdentifier(i)
                      a.alias = h
                      for (var c = 0, l = p.instances; c < l.length; c += 1)
                        l[c].alias = h
                      break
                    }
                  }
              }),
              (e.prototype.transpile = function (e, i) {
                t.prototype.transpile.call(this, e, i),
                  i.trailingFunctionCommas &&
                    this.params.length &&
                    Ue(e, this.params[this.params.length - 1].end)
              }),
              e
            )
          })(_e),
          pi = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.findScope = function (t) {
                return (this.parent.params &&
                  ~this.parent.params.indexOf(this)) ||
                  ('FunctionExpression' === this.parent.type &&
                    this === this.parent.id)
                  ? this.parent.body.scope
                  : this.parent.findScope(t)
              }),
              (e.prototype.initialise = function (t) {
                if (
                  (function t(e, i) {
                    return 'MemberExpression' === e.type
                      ? !e.computed && t(e.object, e)
                      : 'Identifier' === e.type
                      ? !i ||
                        (!/(Function|Class)Expression/.test(i.type) &&
                          ('VariableDeclarator' === i.type
                            ? e === i.init
                            : 'MemberExpression' === i.type ||
                              'MethodDefinition' === i.type
                            ? i.computed || e === i.object
                            : 'ArrayPattern' !== i.type &&
                              ('Property' === i.type
                                ? 'ObjectPattern' !== i.parent.type &&
                                  (i.computed || e === i.value)
                                : 'MethodDefinition' !== i.type &&
                                  ('ExportSpecifier' !== i.type ||
                                    e === i.local))))
                      : void 0
                  })(this, this.parent)
                ) {
                  if (
                    t.arrow &&
                    'arguments' === this.name &&
                    !this.findScope(!1).contains(this.name)
                  ) {
                    var e = this.findLexicalBoundary(),
                      i = this.findNearest('ArrowFunctionExpression'),
                      s = this.findNearest(He)
                    i &&
                      i.depth > e.depth &&
                      (this.alias = e.getArgumentsAlias()),
                      s &&
                        s.body.contains(this) &&
                        s.depth > e.depth &&
                        (this.alias = e.getArgumentsAlias())
                  }
                  this.findScope(!1).addReference(this)
                }
              }),
              (e.prototype.transpile = function (t) {
                this.alias &&
                  t.overwrite(this.start, this.end, this.alias, {
                    storeName: !0,
                    contentOnly: !0,
                  })
              }),
              e
            )
          })(_e),
          hi = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                t.prototype.initialise.call(this, e)
              }),
              (e.prototype.transpile = function (e, i) {
                ;('BlockStatement' !== this.consequent.type ||
                  ('BlockStatement' === this.consequent.type &&
                    this.consequent.synthetic)) &&
                  (e.appendLeft(this.consequent.start, '{ '),
                  e.prependRight(this.consequent.end, ' }')),
                  this.alternate &&
                    'IfStatement' !== this.alternate.type &&
                    ('BlockStatement' !== this.alternate.type ||
                      ('BlockStatement' === this.alternate.type &&
                        this.alternate.synthetic)) &&
                    (e.appendLeft(this.alternate.start, '{ '),
                    e.prependRight(this.alternate.end, ' }')),
                  t.prototype.transpile.call(this, e, i)
              }),
              e
            )
          })(_e),
          ci = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                e.moduleImport &&
                  Ie.missingTransform(
                    'dynamic import expressions',
                    'moduleImport',
                    this
                  ),
                  t.prototype.initialise.call(this, e)
              }),
              e
            )
          })(_e),
          li = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                e.moduleImport &&
                  Ie.missingTransform('import', 'moduleImport', this),
                  t.prototype.initialise.call(this, e)
              }),
              e
            )
          })(_e),
          ui = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                this.findScope(!0).addDeclaration(this.local, 'import'),
                  t.prototype.initialise.call(this, e)
              }),
              e
            )
          })(_e),
          di = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.initialise = function (e) {
                this.findScope(!0).addDeclaration(this.local, 'import'),
                  t.prototype.initialise.call(this, e)
              }),
              e
            )
          })(_e),
          fi = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.transpile = function (e, i) {
                var s,
                  r = this.name
                e.overwrite(
                  r.start,
                  this.value ? this.value.start : this.name.end,
                  (/-/.test((s = r.name)) ? "'" + s + "'" : s) +
                    ': ' +
                    (this.value ? '' : 'true')
                ),
                  t.prototype.transpile.call(this, e, i)
              }),
              e
            )
          })(_e),
          mi = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.transpile = function (t) {
                var e,
                  i = !0,
                  s = this.parent.children[this.parent.children.length - 1]
                ;((s &&
                  'JSXText' === (e = s).type &&
                  !/\S/.test(e.value) &&
                  /\n/.test(e.value)) ||
                  this.parent.openingElement.attributes.length) &&
                  (i = !1),
                  t.overwrite(this.start, this.end, i ? ' )' : ')')
              }),
              e
            )
          })(_e),
          yi = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.transpile = function (t) {
                var e,
                  i = !0,
                  s = this.parent.children[this.parent.children.length - 1]
                s &&
                  'JSXText' === (e = s).type &&
                  !/\S/.test(e.value) &&
                  /\n/.test(e.value) &&
                  (i = !1),
                  t.overwrite(this.start, this.end, i ? ' )' : ')')
              }),
              e
            )
          })(_e)
        function gi(t, e) {
          return (
            (t = t.replace(/\u00a0/g, '&nbsp;')),
            e && /\n/.test(t) && (t = t.replace(/\s+$/, '')),
            (t = t.replace(/^\n\r?\s+/, '').replace(/\s*\n\r?\s*/gm, ' ')),
            JSON.stringify(t)
          )
        }
        var vi = (function (t) {
            function e() {
              t.apply(this, arguments)
            }
            return (
              t && (e.__proto__ = t),
              ((e.prototype = Object.create(t && t.prototype)).constructor = e),
              (e.prototype.transpile = function (e, i) {
                t.prototype.transpile.call(this, e, i)
                var s = this.children.filter(function (t) {
                  return (
                    'JSXText' !== t.type ||
                    /\S/.test(t.raw) ||
                    !/\n/.test(t.raw)
                  )
                })
                if (s.length) {
                  var r,
                    n = (this.openingElement || this.openingFragment).end
                  for (r = 0; r < s.length; r += 1) {
                    var a = s[r]
                    if (
                      (('JSXExpressionContainer' === a.type &&
                        'JSXEmptyExpression' === a.expression.type) ||
                        e.appendLeft(
                          n,
                          ',' +
                            ('\n' === e.original[n] && 'JSXText' !== a.type
                              ? ''
                              : ' ')
                        ),
                      'JSXText' === a.type)
                    ) {
                      var o = gi(a.value, r === s.length - 1)
                      e.overwrite(a.start, a.end, o)
                    }
                    n = a.end
                  }
                }
              }),
              e
            )
          })(_e),
          xi = /[\u2028-\u2029]/g,
          bi = {
            ArrayExpression: Me,
            ArrowFunctionExpression: qe,
            AssignmentExpression: Xe,
            AwaitExpression: ze,
            BinaryExpression: We,
            BreakStatement: Ge,
            CallExpression: Qe,
            ClassBody: Ke,
            ClassDeclaration: $e,
            ClassExpression: Ze,
            ContinueStatement: Ye,
            DoWhileStatement: ii,
            ExportNamedDeclaration: ei,
            ExportDefaultDeclaration: ti,
            ForStatement: si,
            ForInStatement: ri,
            ForOfStatement: ni,
            FunctionDeclaration: ai,
            FunctionExpression: oi,
            Identifier: pi,
            IfStatement: hi,
            Import: ci,
            ImportDeclaration: li,
            ImportDefaultSpecifier: ui,
            ImportSpecifier: di,
            JSXAttribute: fi,
            JSXClosingElement: mi,
            JSXClosingFragment: yi,
            JSXElement: vi,
            JSXExpressionContainer: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.transpile = function (e, i) {
                  e.remove(this.start, this.expression.start),
                    e.remove(this.expression.end, this.end),
                    t.prototype.transpile.call(this, e, i)
                }),
                e
              )
            })(_e),
            JSXFragment: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                e
              )
            })(vi),
            JSXOpeningElement: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.transpile = function (e, i) {
                  t.prototype.transpile.call(this, e, i),
                    e.overwrite(
                      this.start,
                      this.name.start,
                      this.program.jsx + '( '
                    )
                  var s =
                    'JSXIdentifier' === this.name.type &&
                    this.name.name[0] === this.name.name[0].toLowerCase()
                  s && e.prependRight(this.name.start, "'")
                  var r = this.attributes.length,
                    n = this.name.end
                  if (r) {
                    var a,
                      o,
                      p,
                      h = !1
                    for (a = 0; a < r; a += 1)
                      if ('JSXSpreadAttribute' === this.attributes[a].type) {
                        h = !0
                        break
                      }
                    for (n = this.attributes[0].end, a = 0; a < r; a += 1) {
                      var c = this.attributes[a]
                      if (
                        (a > 0 &&
                          (c.start === n
                            ? e.prependRight(n, ', ')
                            : e.overwrite(n, c.start, ', ')),
                        h && 'JSXSpreadAttribute' !== c.type)
                      ) {
                        var l = this.attributes[a - 1],
                          u = this.attributes[a + 1]
                        ;(l && 'JSXSpreadAttribute' !== l.type) ||
                          e.prependRight(c.start, '{ '),
                          (u && 'JSXSpreadAttribute' !== u.type) ||
                            e.appendLeft(c.end, ' }')
                      }
                      n = c.end
                    }
                    if (h)
                      if (1 === r) p = s ? "'," : ','
                      else {
                        if (!this.program.options.objectAssign)
                          throw new Ie(
                            "Mixed JSX attributes ending in spread requires specified objectAssign option with 'Object.assign' or polyfill helper.",
                            this
                          )
                        ;(p = s
                          ? "', " + this.program.options.objectAssign + '({},'
                          : ', ' + this.program.options.objectAssign + '({},'),
                          (o = ')')
                      }
                    else (p = s ? "', {" : ', {'), (o = ' }')
                    e.prependRight(this.name.end, p),
                      o && e.appendLeft(this.attributes[r - 1].end, o)
                  } else
                    e.appendLeft(this.name.end, s ? "', null" : ', null'),
                      (n = this.name.end)
                  this.selfClosing
                    ? e.overwrite(
                        n,
                        this.end,
                        this.attributes.length ? ')' : ' )'
                      )
                    : e.remove(n, this.end)
                }),
                e
              )
            })(_e),
            JSXOpeningFragment: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.transpile = function (t) {
                  t.overwrite(
                    this.start,
                    this.end,
                    this.program.jsx + '( React.Fragment, null'
                  )
                }),
                e
              )
            })(_e),
            JSXSpreadAttribute: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.transpile = function (e, i) {
                  e.remove(this.start, this.argument.start),
                    e.remove(this.argument.end, this.end),
                    t.prototype.transpile.call(this, e, i)
                }),
                e
              )
            })(_e),
            Literal: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.initialise = function () {
                  'string' == typeof this.value &&
                    this.program.indentExclusionElements.push(this)
                }),
                (e.prototype.transpile = function (t, e) {
                  e.numericLiteral &&
                    this.raw.match(/^0[bo]/i) &&
                    t.overwrite(this.start, this.end, String(this.value), {
                      storeName: !0,
                      contentOnly: !0,
                    }),
                    'string' == typeof this.value &&
                      this.value.match(xi) &&
                      t.overwrite(
                        this.start,
                        this.end,
                        this.raw.replace(xi, function (t) {
                          return '\u2028' == t ? '\\u2028' : '\\u2029'
                        }),
                        { contentOnly: !0 }
                      )
                }),
                e
              )
            })(_e),
            MemberExpression: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.transpile = function (e, i) {
                  i.reservedProperties &&
                    we[this.property.name] &&
                    (e.overwrite(this.object.end, this.property.start, "['"),
                    e.appendLeft(this.property.end, "']")),
                    t.prototype.transpile.call(this, e, i)
                }),
                e
              )
            })(_e),
            NewExpression: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.initialise = function (e) {
                  if (e.spreadRest && this.arguments.length)
                    for (
                      var i = this.findLexicalBoundary(),
                        s = this.arguments.length;
                      s--;

                    ) {
                      var r = this.arguments[s]
                      if ('SpreadElement' === r.type && Ve(r.argument)) {
                        this.argumentsArrayAlias = i.getArgumentsArrayAlias()
                        break
                      }
                    }
                  t.prototype.initialise.call(this, e)
                }),
                (e.prototype.transpile = function (e, i) {
                  if (
                    (t.prototype.transpile.call(this, e, i),
                    i.spreadRest &&
                      this.arguments.length &&
                      De(e, this, this.arguments),
                    i.spreadRest && this.arguments.length)
                  ) {
                    var s = this.arguments[0]
                    Fe(
                      e,
                      this.arguments,
                      s.start,
                      this.argumentsArrayAlias,
                      !0
                    ) &&
                      (e.prependRight(
                        this.start + 'new'.length,
                        ' (Function.prototype.bind.apply('
                      ),
                      e.overwrite(
                        this.callee.end,
                        s.start,
                        ', [ null ].concat( '
                      ),
                      e.appendLeft(this.end, ' ))'))
                  }
                  this.arguments.length &&
                    Ue(e, this.arguments[this.arguments.length - 1].end)
                }),
                e
              )
            })(_e),
            ObjectExpression: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.transpile = function (e, i) {
                  var s
                  t.prototype.transpile.call(this, e, i)
                  for (
                    var r = this.start + 1,
                      n = 0,
                      a = 0,
                      o = null,
                      p = null,
                      h = 0;
                    h < this.properties.length;
                    ++h
                  ) {
                    var c = this.properties[h]
                    if ('SpreadElement' === c.type) {
                      var l = c.argument
                      'ObjectExpression' === l.type ||
                      ('Literal' === l.type && 'string' != typeof l.value)
                        ? 'ObjectExpression' === l.type &&
                          l.properties.length > 0
                          ? (e.remove(c.start, l.properties[0].start),
                            e.remove(
                              l.properties[l.properties.length - 1].end,
                              c.end
                            ),
                            (s = this.properties).splice.apply(
                              s,
                              [h, 1].concat(l.properties)
                            ),
                            h--)
                          : (e.remove(
                              c.start,
                              h === this.properties.length - 1
                                ? c.end
                                : this.properties[h + 1].start
                            ),
                            this.properties.splice(h, 1),
                            h--)
                        : ((n += 1), null === o && (o = h))
                    } else
                      c.computed &&
                        i.computedProperty &&
                        ((a += 1), null === p && (p = h))
                  }
                  if (!n || i.objectRestSpread || (a && i.computedProperty)) {
                    if (n) {
                      if (!this.program.options.objectAssign)
                        throw new Ie(
                          "Object spread operator requires specified objectAssign option with 'Object.assign' or polyfill helper.",
                          this
                        )
                      for (var u = this.properties.length; u--; ) {
                        var d = this.properties[u]
                        if ('Property' === d.type && !a) {
                          var f = this.properties[u - 1],
                            m = this.properties[u + 1]
                          ;(f && 'Property' === f.type) ||
                            e.prependRight(d.start, '{'),
                            (m && 'Property' === m.type) ||
                              e.appendLeft(d.end, '}')
                        }
                        'SpreadElement' === d.type &&
                          (e.remove(d.start, d.argument.start),
                          e.remove(d.argument.end, d.end))
                      }
                      ;(r = this.properties[0].start),
                        a
                          ? 'SpreadElement' === this.properties[0].type
                            ? (e.overwrite(
                                this.start,
                                r,
                                this.program.options.objectAssign + '({}, '
                              ),
                              e.remove(this.end - 1, this.end),
                              e.appendRight(this.end, ')'))
                            : (e.prependLeft(
                                this.start,
                                this.program.options.objectAssign + '('
                              ),
                              e.appendRight(this.end, ')'))
                          : (e.overwrite(
                              this.start,
                              r,
                              this.program.options.objectAssign + '({}, '
                            ),
                            e.overwrite(
                              this.properties[this.properties.length - 1].end,
                              this.end,
                              ')'
                            ))
                    }
                  } else (n = 0), (o = null)
                  if (a && i.computedProperty) {
                    var y,
                      g,
                      v = this.getIndentation()
                    'VariableDeclarator' === this.parent.type &&
                    1 === this.parent.parent.declarations.length &&
                    'Identifier' === this.parent.id.type
                      ? ((y = !0),
                        (g = this.parent.id.alias || this.parent.id.name))
                      : (('AssignmentExpression' === this.parent.type &&
                          'ExpressionStatement' === this.parent.parent.type &&
                          'Identifier' === this.parent.left.type) ||
                          ('AssignmentPattern' === this.parent.type &&
                            'Identifier' === this.parent.left.type)) &&
                        ((y = !0),
                        (g = this.parent.left.alias || this.parent.left.name)),
                      n && (y = !1),
                      (g = this.findScope(!1).resolveName(g))
                    var x = r,
                      b = this.end
                    y ||
                      (null === o || p < o
                        ? ((g = this.findScope(!0).createDeclaration('obj')),
                          e.prependRight(this.start, '( ' + g + ' = '))
                        : (g = null))
                    for (
                      var _, k = this.properties.length, S = !1, w = !0, E = 0;
                      E < k;
                      E += 1
                    ) {
                      var C = this.properties[E],
                        A = E > 0 ? this.properties[E - 1].end : x
                      if ('Property' === C.type && (C.computed || (_ && !n))) {
                        if ((0 === E && (A = this.start + 1), (_ = C), g)) {
                          var I =
                            (y ? ';\n' + v + g : ', ' + g) +
                            ('Literal' === C.key.type || C.computed ? '' : '.')
                          A < C.start
                            ? e.overwrite(A, C.start, I)
                            : e.prependRight(C.start, I)
                        } else
                          (g = this.findScope(!0).createDeclaration('obj')),
                            e.appendRight(
                              C.start,
                              '( ' + g + ' = {}, ' + g + (C.computed ? '' : '.')
                            )
                        var L = C.key.end
                        if (C.computed) {
                          for (; ']' !== e.original[L]; ) L += 1
                          L += 1
                        }
                        'Literal' !== C.key.type || C.computed
                          ? C.shorthand ||
                            (C.method && !C.computed && i.conciseMethodProperty)
                            ? e.overwrite(
                                C.key.start,
                                C.key.end,
                                e
                                  .slice(C.key.start, C.key.end)
                                  .replace(/:/, ' =')
                              )
                            : (C.value.start > L && e.remove(L, C.value.start),
                              e.prependLeft(L, ' = '))
                          : e.overwrite(
                              C.start,
                              C.key.end + 1,
                              '[' + e.slice(C.start, C.key.end) + '] = '
                            ),
                          !C.method ||
                            (!C.computed && i.conciseMethodProperty) ||
                            (C.value.generator &&
                              e.remove(C.start, C.key.start),
                            e.prependRight(
                              C.value.start,
                              'function' + (C.value.generator ? '*' : '') + ' '
                            ))
                      } else
                        'SpreadElement' === C.type
                          ? g &&
                            E > 0 &&
                            (_ || (_ = this.properties[E - 1]),
                            e.appendLeft(_.end, ', ' + g + ' )'),
                            (_ = null),
                            (g = null))
                          : (!w &&
                              n &&
                              (e.prependRight(C.start, '{'),
                              e.appendLeft(C.end, '}')),
                            (S = !0))
                      if (w && ('SpreadElement' === C.type || C.computed)) {
                        var P = S
                          ? this.properties[this.properties.length - 1].end
                          : this.end - 1
                        ',' == e.original[P] && ++P
                        var N = e.slice(P, b)
                        e.prependLeft(A, N), e.remove(P, b), (w = !1)
                      }
                      var O = C.end
                      if (E < k - 1 && !S)
                        for (; ',' !== e.original[O]; ) O += 1
                      else E == k - 1 && (O = this.end)
                      C.end != O &&
                        e.overwrite(C.end, O, '', { contentOnly: !0 })
                    }
                    !y && g && e.appendLeft(_.end, ', ' + g + ' )')
                  }
                }),
                e
              )
            })(_e),
            Property: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.initialise = function (e) {
                  ;('get' !== this.kind && 'set' !== this.kind) ||
                    !e.getterSetter ||
                    Ie.missingTransform(
                      'getters and setters',
                      'getterSetter',
                      this
                    ),
                    t.prototype.initialise.call(this, e)
                }),
                (e.prototype.transpile = function (e, i) {
                  if (
                    (t.prototype.transpile.call(this, e, i),
                    i.conciseMethodProperty &&
                      !this.computed &&
                      'ObjectPattern' !== this.parent.type)
                  )
                    if (this.shorthand)
                      e.prependRight(this.start, this.key.name + ': ')
                    else if (this.method) {
                      var s = ''
                      !1 !== this.program.options.namedFunctionExpressions &&
                        (s =
                          ' ' +
                          (s =
                            'Literal' === this.key.type &&
                            'number' == typeof this.key.value
                              ? ''
                              : 'Identifier' === this.key.type
                              ? we[this.key.name] ||
                                !/^[a-z_$][a-z0-9_$]*$/i.test(this.key.name) ||
                                this.value.body.scope.references[this.key.name]
                                ? this.findScope(!0).createIdentifier(
                                    this.key.name
                                  )
                                : this.key.name
                              : this.findScope(!0).createIdentifier(
                                  this.key.value
                                ))),
                        this.start < this.key.start &&
                          e.remove(this.start, this.key.start),
                        e.appendLeft(
                          this.key.end,
                          ': ' +
                            (this.value.async ? 'async ' : '') +
                            'function' +
                            (this.value.generator ? '*' : '') +
                            s
                        )
                    }
                  i.reservedProperties &&
                    we[this.key.name] &&
                    (e.prependRight(this.key.start, "'"),
                    e.appendLeft(this.key.end, "'"))
                }),
                e
              )
            })(_e),
            ReturnStatement: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.initialise = function (t) {
                  ;(this.loop = this.findNearest(He)),
                    (this.nearestFunction = this.findNearest(/Function/)),
                    this.loop &&
                      (!this.nearestFunction ||
                        this.loop.depth > this.nearestFunction.depth) &&
                      ((this.loop.canReturn = !0), (this.shouldWrap = !0)),
                    this.argument && this.argument.initialise(t)
                }),
                (e.prototype.transpile = function (t, e) {
                  var i =
                    this.shouldWrap &&
                    this.loop &&
                    this.loop.shouldRewriteAsFunction
                  this.argument
                    ? (i && t.prependRight(this.argument.start, '{ v: '),
                      this.argument.transpile(t, e),
                      i && t.appendLeft(this.argument.end, ' }'))
                    : i && t.appendLeft(this.start + 6, ' {}')
                }),
                e
              )
            })(_e),
            Super: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.initialise = function (t) {
                  if (t.classes) {
                    if (
                      ((this.method = this.findNearest('MethodDefinition')),
                      !this.method)
                    )
                      throw new Ie('use of super outside class method', this)
                    var e = this.findNearest('ClassBody').parent
                    if (
                      ((this.superClassName =
                        e.superClass && (e.superClass.name || 'superclass')),
                      !this.superClassName)
                    )
                      throw new Ie('super used in base class', this)
                    if (
                      ((this.isCalled =
                        'CallExpression' === this.parent.type &&
                        this === this.parent.callee),
                      'constructor' !== this.method.kind && this.isCalled)
                    )
                      throw new Ie(
                        'super() not allowed outside class constructor',
                        this
                      )
                    if (
                      ((this.isMember =
                        'MemberExpression' === this.parent.type),
                      !this.isCalled && !this.isMember)
                    )
                      throw new Ie(
                        'Unexpected use of `super` (expected `super(...)` or `super.*`)',
                        this
                      )
                  }
                  if (t.arrow) {
                    var i = this.findLexicalBoundary(),
                      s = this.findNearest('ArrowFunctionExpression'),
                      r = this.findNearest(He)
                    s &&
                      s.depth > i.depth &&
                      (this.thisAlias = i.getThisAlias()),
                      r &&
                        r.body.contains(this) &&
                        r.depth > i.depth &&
                        (this.thisAlias = i.getThisAlias())
                  }
                }),
                (e.prototype.transpile = function (t, e) {
                  if (e.classes) {
                    t.overwrite(
                      this.start,
                      this.end,
                      this.isCalled || this.method.static
                        ? this.superClassName
                        : this.superClassName + '.prototype',
                      { storeName: !0, contentOnly: !0 }
                    )
                    var i = this.isCalled ? this.parent : this.parent.parent
                    if (i && 'CallExpression' === i.type) {
                      this.noCall || t.appendLeft(i.callee.end, '.call')
                      var s = this.thisAlias || 'this'
                      i.arguments.length
                        ? t.appendLeft(i.arguments[0].start, s + ', ')
                        : t.appendLeft(i.end - 1, '' + s)
                    }
                  }
                }),
                e
              )
            })(_e),
            TaggedTemplateExpression: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.initialise = function (e) {
                  e.templateString &&
                    !e.dangerousTaggedTemplateString &&
                    Ie.missingTransform(
                      'tagged template strings',
                      'templateString',
                      this,
                      'dangerousTaggedTemplateString'
                    ),
                    t.prototype.initialise.call(this, e)
                }),
                (e.prototype.transpile = function (e, i) {
                  if (i.templateString && i.dangerousTaggedTemplateString) {
                    var s = this.quasi.expressions
                        .concat(this.quasi.quasis)
                        .sort(function (t, e) {
                          return t.start - e.start
                        }),
                      r = this.program.body.scope,
                      n = this.quasi.quasis
                        .map(function (t) {
                          return JSON.stringify(t.value.cooked)
                        })
                        .join(', '),
                      a = this.program.templateLiteralQuasis[n]
                    a ||
                      ((a = r.createIdentifier('templateObject')),
                      e.prependLeft(
                        this.program.prependAt,
                        'var ' + a + ' = Object.freeze([' + n + ']);\n'
                      ),
                      (this.program.templateLiteralQuasis[n] = a)),
                      e.overwrite(this.tag.end, s[0].start, '(' + a)
                    var o = s[0].start
                    s.forEach(function (t) {
                      'TemplateElement' === t.type
                        ? e.remove(o, t.end)
                        : e.overwrite(o, t.start, ', '),
                        (o = t.end)
                    }),
                      e.overwrite(o, this.end, ')')
                  }
                  t.prototype.transpile.call(this, e, i)
                }),
                e
              )
            })(_e),
            TemplateElement: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.initialise = function () {
                  this.program.indentExclusionElements.push(this)
                }),
                e
              )
            })(_e),
            TemplateLiteral: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.transpile = function (e, i) {
                  if (
                    (t.prototype.transpile.call(this, e, i),
                    i.templateString &&
                      'TaggedTemplateExpression' !== this.parent.type)
                  ) {
                    var s = this.expressions
                      .concat(this.quasis)
                      .sort(function (t, e) {
                        return t.start - e.start || t.end - e.end
                      })
                      .filter(function (t, e) {
                        return (
                          'TemplateElement' !== t.type || !!t.value.raw || !e
                        )
                      })
                    if (s.length >= 3) {
                      var r = s[0]
                      'TemplateElement' === r.type &&
                        '' === r.value.raw &&
                        'TemplateElement' === s[2].type &&
                        s.shift()
                    }
                    var n = !(
                      (1 === this.quasis.length &&
                        0 === this.expressions.length) ||
                      'TemplateLiteral' === this.parent.type ||
                      'AssignmentExpression' === this.parent.type ||
                      'AssignmentPattern' === this.parent.type ||
                      'VariableDeclarator' === this.parent.type ||
                      ('BinaryExpression' === this.parent.type &&
                        '+' === this.parent.operator)
                    )
                    n && e.appendRight(this.start, '(')
                    var a = this.start
                    s.forEach(function (t, i) {
                      var s = 0 === i ? (n ? '(' : '') : ' + '
                      if ('TemplateElement' === t.type)
                        e.overwrite(
                          a,
                          t.end,
                          s + JSON.stringify(t.value.cooked)
                        )
                      else {
                        var r = 'Identifier' !== t.type
                        r && (s += '('),
                          e.remove(a, t.start),
                          s && e.prependRight(t.start, s),
                          r && e.appendLeft(t.end, ')')
                      }
                      a = t.end
                    }),
                      n && e.appendLeft(a, ')'),
                      e.overwrite(a, this.end, '', { contentOnly: !0 })
                  }
                }),
                e
              )
            })(_e),
            ThisExpression: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.initialise = function (t) {
                  var e = this.findLexicalBoundary()
                  if (t.letConst)
                    for (var i = this.findNearest(He); i && i.depth > e.depth; )
                      i.thisRefs.push(this), (i = i.parent.findNearest(He))
                  if (t.arrow) {
                    var s = this.findNearest('ArrowFunctionExpression')
                    s && s.depth > e.depth && (this.alias = e.getThisAlias())
                  }
                }),
                (e.prototype.transpile = function (t) {
                  this.alias &&
                    t.overwrite(this.start, this.end, this.alias, {
                      storeName: !0,
                      contentOnly: !0,
                    })
                }),
                e
              )
            })(_e),
            UpdateExpression: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.initialise = function (e) {
                  if ('Identifier' === this.argument.type) {
                    var i = this.findScope(!1).findDeclaration(
                        this.argument.name
                      ),
                      s = i && i.node.ancestor(3)
                    s &&
                      'ForStatement' === s.type &&
                      s.body.contains(this) &&
                      (s.reassigned[this.argument.name] = !0)
                  }
                  t.prototype.initialise.call(this, e)
                }),
                (e.prototype.transpile = function (e, i) {
                  'Identifier' === this.argument.type &&
                    Je(this.argument, this.findScope(!1)),
                    t.prototype.transpile.call(this, e, i)
                }),
                e
              )
            })(_e),
            VariableDeclaration: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.initialise = function (t) {
                  ;(this.scope = this.findScope('var' === this.kind)),
                    this.declarations.forEach(function (e) {
                      return e.initialise(t)
                    })
                }),
                (e.prototype.transpile = function (t, e) {
                  var i = this,
                    s = this.getIndentation(),
                    r = this.kind
                  if (
                    (e.letConst &&
                      'var' !== r &&
                      t.overwrite(
                        this.start,
                        this.start + this.kind.length,
                        (r = 'var'),
                        { contentOnly: !0, storeName: !0 }
                      ),
                    e.destructuring &&
                      'ForOfStatement' !== this.parent.type &&
                      'ForInStatement' !== this.parent.type)
                  ) {
                    var n,
                      a = this.start
                    this.declarations.forEach(function (r, o) {
                      if ((r.transpile(t, e), 'Identifier' === r.id.type))
                        o > 0 &&
                          'Identifier' !== i.declarations[o - 1].id.type &&
                          t.overwrite(a, r.id.start, 'var ')
                      else {
                        var p = He.test(i.parent.type)
                        0 === o
                          ? t.remove(a, r.id.start)
                          : t.overwrite(a, r.id.start, ';\n' + s)
                        var h =
                            'Identifier' === r.init.type && !r.init.rewritten,
                          c = h
                            ? r.init.alias || r.init.name
                            : r.findScope(!0).createIdentifier('ref')
                        a = r.start
                        var l = []
                        h
                          ? t.remove(r.id.end, r.end)
                          : l.push(function (e, i, s) {
                              t.prependRight(r.id.end, 'var ' + c),
                                t.appendLeft(r.init.end, '' + s),
                                t.move(r.id.end, r.end, e)
                            })
                        var u = r.findScope(!1)
                        Ne(
                          t,
                          function (t) {
                            return u.createIdentifier(t)
                          },
                          function (t) {
                            return u.resolveName(t.name)
                          },
                          r.id,
                          c,
                          p,
                          l
                        )
                        var d = p ? 'var ' : '',
                          f = p ? ', ' : ';\n' + s
                        l.forEach(function (t, e) {
                          o === i.declarations.length - 1 &&
                            e === l.length - 1 &&
                            (f = p ? '' : ';'),
                            t(r.start, 0 === e ? d : '', f)
                        })
                      }
                      ;(a = r.end), (n = 'Identifier' !== r.id.type)
                    }),
                      n &&
                        this.end > a &&
                        t.overwrite(a, this.end, '', { contentOnly: !0 })
                  } else
                    this.declarations.forEach(function (i) {
                      i.transpile(t, e)
                    })
                }),
                e
              )
            })(_e),
            VariableDeclarator: (function (t) {
              function e() {
                t.apply(this, arguments)
              }
              return (
                t && (e.__proto__ = t),
                ((e.prototype = Object.create(
                  t && t.prototype
                )).constructor = e),
                (e.prototype.initialise = function (e) {
                  var i = this.parent.kind
                  'let' === i &&
                    'ForStatement' === this.parent.parent.type &&
                    (i = 'for.let'),
                    this.parent.scope.addDeclaration(this.id, i),
                    t.prototype.initialise.call(this, e)
                }),
                (e.prototype.transpile = function (t, e) {
                  if (!this.init && e.letConst && 'var' !== this.parent.kind) {
                    var i = this.findNearest(
                      /Function|^For(In|Of)?Statement|^(?:Do)?WhileStatement/
                    )
                    !i ||
                      /Function/.test(i.type) ||
                      this.isLeftDeclaratorOfLoop() ||
                      t.appendLeft(this.id.end, ' = (void 0)')
                  }
                  this.id && this.id.transpile(t, e),
                    this.init && this.init.transpile(t, e)
                }),
                (e.prototype.isLeftDeclaratorOfLoop = function () {
                  return (
                    this.parent &&
                    'VariableDeclaration' === this.parent.type &&
                    this.parent.parent &&
                    ('ForInStatement' === this.parent.parent.type ||
                      'ForOfStatement' === this.parent.parent.type) &&
                    this.parent.parent.left &&
                    this.parent.parent.left.declarations[0] === this
                  )
                }),
                e
              )
            })(_e),
            WhileStatement: ii,
          },
          _i = { Program: ['body'], Literal: [] },
          ki = {
            IfStatement: 'consequent',
            ForStatement: 'body',
            ForInStatement: 'body',
            ForOfStatement: 'body',
            WhileStatement: 'body',
            DoWhileStatement: 'body',
            ArrowFunctionExpression: 'body',
          }
        function Si(t, e, i, s) {
          ;(this.type = 'Root'),
            (this.jsx = s.jsx || 'React.createElement'),
            (this.options = s),
            (this.source = t),
            (this.magicString = new xe(t)),
            (this.ast = e),
            (this.depth = 0),
            (function t(e, i) {
              if (e)
                if ('length' in e) for (var s = e.length; s--; ) t(e[s], i)
                else if (!e.__wrapped) {
                  ;(e.__wrapped = !0),
                    _i[e.type] ||
                      (_i[e.type] = Object.keys(e).filter(function (t) {
                        return 'object' == typeof e[t]
                      }))
                  var r = ki[e.type]
                  if (r && 'BlockStatement' !== e[r].type) {
                    var n = e[r]
                    e[r] = {
                      start: n.start,
                      end: n.end,
                      type: 'BlockStatement',
                      body: [n],
                      synthetic: !0,
                    }
                  }
                  ;(e.parent = i),
                    (e.program = i.program || i),
                    (e.depth = i.depth + 1),
                    (e.keys = _i[e.type]),
                    (e.indentation = void 0)
                  for (var a = 0, o = _i[e.type]; a < o.length; a += 1)
                    t(e[o[a]], e)
                  e.program.magicString.addSourcemapLocation(e.start),
                    e.program.magicString.addSourcemapLocation(e.end),
                    (e.__proto__ = (
                      ('BlockStatement' === e.type ? Re : bi[e.type]) || _e
                    ).prototype)
                }
            })((this.body = e), this),
            (this.body.__proto__ = Re.prototype),
            (this.templateLiteralQuasis = Object.create(null))
          for (var r = 0; r < this.body.body.length; ++r)
            if (!this.body.body[r].directive) {
              this.prependAt = this.body.body[r].start
              break
            }
          ;(this.objectWithoutPropertiesHelper = null),
            (this.indentExclusionElements = []),
            this.body.initialise(i),
            (this.indentExclusions = Object.create(null))
          for (
            var n = 0, a = this.indentExclusionElements;
            n < a.length;
            n += 1
          )
            for (var o = a[n], p = o.start; p < o.end; p += 1)
              this.indentExclusions[p] = !0
          this.body.transpile(this.magicString, i)
        }
        Si.prototype = {
          export: function (t) {
            return (
              void 0 === t && (t = {}),
              {
                code: this.magicString.toString(),
                map: this.magicString.generateMap({
                  file: t.file,
                  source: t.source,
                  includeContent: !1 !== t.includeContent,
                }),
              }
            )
          },
          findNearest: function () {
            return null
          },
          findScope: function () {
            return null
          },
          getObjectWithoutPropertiesHelper: function (t) {
            return (
              this.objectWithoutPropertiesHelper ||
                ((this.objectWithoutPropertiesHelper = this.body.scope.createIdentifier(
                  'objectWithoutProperties'
                )),
                t.prependLeft(
                  this.prependAt,
                  'function ' +
                    this.objectWithoutPropertiesHelper +
                    ' (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }\n'
                )),
              this.objectWithoutPropertiesHelper
            )
          },
        }
        var wi = H.extend(se, te(), function (t) {
            return (function (t) {
              Object(a.a)(i, t)
              var e = h(i)
              function i() {
                return Object(s.a)(this, i), e.apply(this, arguments)
              }
              return (
                Object(r.a)(i, [
                  {
                    key: 'getTokenFromCode',
                    value: function (t) {
                      if (35 === t) {
                        ++this.pos
                        var e = this.readWord1()
                        return this.finishToken(pe, e)
                      }
                      return Object(n.a)(
                        Object(p.a)(i.prototype),
                        'getTokenFromCode',
                        this
                      ).call(this, t)
                    },
                  },
                  {
                    key: 'parseClass',
                    value: function (t, e) {
                      this._privateBoundNamesStack =
                        this._privateBoundNamesStack || []
                      var s = Object.create(
                        this._privateBoundNamesStack[
                          this._privateBoundNamesStack.length - 1
                        ] || null
                      )
                      this._privateBoundNamesStack.push(s),
                        (this._unresolvedPrivateNamesStack =
                          this._unresolvedPrivateNamesStack || [])
                      var r = Object.create(null)
                      this._unresolvedPrivateNamesStack.push(r)
                      var a = Object(n.a)(
                        Object(p.a)(i.prototype),
                        'parseClass',
                        this
                      ).call(this, t, e)
                      if (
                        (this._privateBoundNamesStack.pop(),
                        this._unresolvedPrivateNamesStack.pop(),
                        this._unresolvedPrivateNamesStack.length)
                      )
                        Object.assign(
                          this._unresolvedPrivateNamesStack[
                            this._unresolvedPrivateNamesStack.length - 1
                          ],
                          r
                        )
                      else {
                        var o = Object.keys(r)
                        o.length &&
                          (o.sort(function (t, e) {
                            return r[t] - r[e]
                          }),
                          this.raise(
                            r[o[0]],
                            'Usage of undeclared private name'
                          ))
                      }
                      return a
                    },
                  },
                  {
                    key: 'parseClassElement',
                    value: function (t) {
                      if (this.eat(ne.semi)) return null
                      var e = this.startNode()
                      if (!(this.options.ecmaVersion >= 8) || this.type != pe) {
                        if (this.isContextual('async')) {
                          re.lastIndex = this.pos
                          var s = re.exec(this.input),
                            r = this.input.charAt(this.pos + s[0].length)
                          if (';' === r || '=' === r)
                            return (
                              (e.key = this.parseIdent(!0)),
                              (e.computed = !1),
                              ae.call(this, e),
                              this.finishNode(e, 'FieldDefinition'),
                              this.semicolon(),
                              e
                            )
                        }
                        return Object(n.a)(
                          Object(p.a)(i.prototype),
                          'parseClassElement',
                          this
                        ).apply(this, arguments)
                      }
                      return (
                        (e.key = oe.call(this)),
                        (e.computed = !1),
                        'constructor' == e.key.name &&
                          this.raise(
                            e.start,
                            'Classes may not have a field named constructor'
                          ),
                        Object.prototype.hasOwnProperty.call(
                          this._privateBoundNamesStack[
                            this._privateBoundNamesStack.length - 1
                          ],
                          e.key.name
                        ) && this.raise(e.start, 'Duplicate private element'),
                        (this._privateBoundNamesStack[
                          this._privateBoundNamesStack.length - 1
                        ][e.key.name] = !0),
                        delete this._unresolvedPrivateNamesStack[
                          this._unresolvedPrivateNamesStack.length - 1
                        ][e.key.name],
                        ae.call(this, e),
                        this.finishNode(e, 'FieldDefinition'),
                        this.semicolon(),
                        e
                      )
                    },
                  },
                  {
                    key: 'parseClassMethod',
                    value: function (t, e, s, r) {
                      return e ||
                        s ||
                        'method' != t.kind ||
                        t.static ||
                        this.options.ecmaVersion < 8 ||
                        this.type == ne.parenL
                        ? Object(n.a)(
                            Object(p.a)(i.prototype),
                            'parseClassMethod',
                            this
                          ).apply(this, arguments)
                        : (ae.call(this, t),
                          delete t.kind,
                          delete t.static,
                          (t = this.finishNode(t, 'FieldDefinition')),
                          this.semicolon(),
                          t)
                    },
                  },
                  {
                    key: 'parseSubscripts',
                    value: function (t, e, s, r) {
                      for (var a; ; ) {
                        if (!(a = this.eat(ne.bracketL)) && !this.eat(ne.dot))
                          return Object(n.a)(
                            Object(p.a)(i.prototype),
                            'parseSubscripts',
                            this
                          ).call(this, t, e, s, r)
                        var o = this.startNodeAt(e, s)
                        ;(o.object = t),
                          a
                            ? (o.property = this.parseExpression())
                            : this.type == pe
                            ? ((o.property = oe.call(this)),
                              (this._privateBoundNamesStack.length &&
                                this._privateBoundNamesStack[
                                  this._privateBoundNamesStack.length - 1
                                ][o.property.name]) ||
                                (this._unresolvedPrivateNamesStack[
                                  this._unresolvedPrivateNamesStack.length - 1
                                ][o.property.name] = o.property.start))
                            : (o.property = this.parseIdent(!0)),
                          (o.computed = Boolean(a)),
                          a && this.expect(ne.bracketR),
                          (t = this.finishNode(o, 'MemberExpression'))
                      }
                    },
                  },
                  {
                    key: 'parseMaybeUnary',
                    value: function (t, e) {
                      var s = Object(n.a)(
                        Object(p.a)(i.prototype),
                        'parseMaybeUnary',
                        this
                      ).call(this, t, e)
                      return (
                        'delete' == s.operator &&
                          'MemberExpression' == s.argument.type &&
                          'PrivateName' == s.argument.property.type &&
                          this.raise(
                            s.start,
                            'Private elements may not be deleted'
                          ),
                        s
                      )
                    },
                  },
                  {
                    key: 'parseIdent',
                    value: function (t, e) {
                      var s = Object(n.a)(
                        Object(p.a)(i.prototype),
                        'parseIdent',
                        this
                      ).call(this, t, e)
                      return (
                        this._inFieldValue &&
                          'arguments' == s.name &&
                          this.raise(
                            s.start,
                            'A class field initializer may not contain arguments'
                          ),
                        s
                      )
                    },
                  },
                  {
                    key: 'parseExprAtom',
                    value: function (t) {
                      var e = Object(n.a)(
                        Object(p.a)(i.prototype),
                        'parseExprAtom',
                        this
                      ).call(this, t)
                      return (
                        this._inFieldValue &&
                          'Super' == e.type &&
                          this.raise(
                            e.start,
                            'A class field initializer may not contain super'
                          ),
                        e
                      )
                    },
                  },
                ]),
                i
              )
            })(t)
          }),
          Ei = [
            'getterSetter',
            'arrow',
            'classes',
            'computedProperty',
            'conciseMethodProperty',
            'defaultParameter',
            'destructuring',
            'forOf',
            'generator',
            'letConst',
            'moduleExport',
            'moduleImport',
            'numericLiteral',
            'parameterDestructuring',
            'spreadRest',
            'stickyRegExp',
            'templateString',
            'exponentiation',
            'reservedProperties',
            'trailingFunctionCommas',
            'asyncAwait',
            'objectRestSpread',
          ],
          Ci = ['dangerousTaggedTemplateString', 'dangerousForOf']
        function Ai(t, e) {
          var i
          void 0 === e && (e = {})
          var s = null
          try {
            ;(i = wi.parse(t, {
              ecmaVersion: 10,
              preserveParens: !0,
              sourceType: 'module',
              allowAwaitOutsideFunction: !0,
              allowReturnOutsideFunction: !0,
              allowHashBang: !0,
              onComment: function (t, e) {
                if (!s) {
                  var i = /@jsx\s+([^\s]+)/.exec(e)
                  i && (s = i[1])
                }
              },
            })),
              (e.jsx = s || e.jsx)
          } catch (e) {
            throw (
              ((e.snippet = Ae(t, e.loc)),
              (e.toString = function () {
                return e.name + ': ' + e.message + '\n' + e.snippet
              }),
              e)
            )
          }
          var r = Object.create(null)
          return (
            Ei.forEach(function (t) {
              r[t] = !0
            }),
            Ci.forEach(function (t) {
              r[t] = !0
            }),
            Object.keys(e.transforms || {}).forEach(function (t) {
              if ('modules' === t)
                return (
                  'moduleImport' in e.transforms ||
                    (r.moduleImport = e.transforms.modules),
                  void (
                    'moduleExport' in e.transforms ||
                    (r.moduleExport = e.transforms.modules)
                  )
                )
              if (!(t in r)) throw new Error("Unknown transform '" + t + "'")
              r[t] = e.transforms[t]
            }),
            !0 === e.objectAssign && (e.objectAssign = 'Object.assign'),
            new Si(t, i, r, e).export(e)
          )
        }
      }.call(this, i('HDXh').Buffer))
    },
  },
])
//# sourceMappingURL=056bf7cd-3a3ef7cb6e35fb704ecd.js.map
